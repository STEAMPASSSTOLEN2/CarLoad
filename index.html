<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
  <title>Slow Drive 3D ‚Äî CarLoad Fixed</title>
  <style>
    html,body{
      height:100%; margin:0; overflow:hidden;
      background:#060812;
      font-family:system-ui,-apple-system,"Apple SD Gothic Neo","Noto Sans KR",sans-serif;
    }
    /* ‚úÖ Safari Ïó¨Î∞± Î∞©ÏßÄ: canvasÎ•º fixedÎ°ú ÏôÑÏ†Ñ Í≥†Ï†ï + Ïä§ÌÉÄÏùº ÏÇ¨Ïù¥Ï¶àÎèÑ Í∞ïÏ†ú */
    #gl{
      position:fixed; left:0; top:0; right:0; bottom:0;
      width:100%; height:100%;
      display:block;
      background:#060812;
    }

    #ui{
      position:fixed;left:14px;top:14px;z-index:10;
      color:#eaf0ff;background:rgba(10,14,26,.55);
      border:1px solid rgba(255,255,255,.10);
      padding:10px 12px;border-radius:14px;backdrop-filter: blur(10px);
      box-shadow:0 12px 32px rgba(0,0,0,.35); user-select:none;
      max-width:min(720px, calc(100vw - 28px));
    }
    .t{font-weight:900;letter-spacing:-.2px}
    .s{color:rgba(234,240,255,.78);font-size:13px;margin-top:6px;line-height:1.35}
    .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap;margin-top:10px}
    label{font-size:12px;color:rgba(234,240,255,.75)}
    select{
      appearance:none;
      padding:8px 10px;border-radius:12px;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(255,255,255,.06);
      color:#eaf0ff; outline:none;
    }
    .kbd{
      font-family:ui-monospace,SFMono-Regular,Menlo,monospace;
      padding:2px 6px;border-radius:8px;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(255,255,255,.06)
    }

    #hud{
      position:fixed;right:14px;top:14px;z-index:10;
      color:#eaf0ff;background:rgba(10,14,26,.55);
      border:1px solid rgba(255,255,255,.10);
      padding:10px 12px;border-radius:14px;backdrop-filter: blur(10px);
      box-shadow:0 12px 32px rgba(0,0,0,.35); user-select:none;
      text-align:right; min-width:210px;
    }
    #hud .big{font-weight:950;font-size:18px}
    #hud .small{color:rgba(234,240,255,.72);font-size:12px;margin-top:2px}

    #hint{
      position:fixed;left:50%;bottom:18px;transform:translateX(-50%);
      color:#eaf0ff;background:rgba(10,14,26,.62);
      border:1px solid rgba(255,255,255,.10);
      padding:10px 14px;border-radius:999px;backdrop-filter: blur(10px);
      box-shadow:0 12px 32px rgba(0,0,0,.35);
      font-size:13px; user-select:none; pointer-events:none;
      opacity:0; transition:opacity .25s ease, transform .25s ease;
      max-width:min(760px, calc(100vw - 28px));
      text-align:center; line-height:1.35;
    }
    #hint.on{opacity:1; transform:translateX(-50%) translateY(-4px);}
  </style>
</head>
<body>
  <canvas id="gl"></canvas>

  <div id="ui">
    <div class="t">Slow Drive 3D ‚Äî CarLoad Fixed</div>
    <div class="s">
      <span class="kbd">W</span>/<span class="kbd">S</span> Í∞ÄÏÜç/Í∞êÏÜç ¬∑
      <span class="kbd">A</span>/<span class="kbd">D</span> Ï°∞Ìñ• ¬∑
      <span class="kbd">Shift</span> Î∂ÄÏä§Ìä∏ ¬∑
      <span class="kbd">1~5</span> Ï∞® Î≥ÄÍ≤Ω ¬∑
      <span class="kbd">F</span> ÏïàÍ∞ú ¬∑
      <span class="kbd">T</span> ÎÇÆ/Î∞§ ¬∑
      <span class="kbd">R</span> Î¶¨ÏÖã
    </div>
    <div class="row">
      <label for="carSel">Ï∞® ÏÑ†ÌÉù</label>
      <select id="carSel"></select>
      <span id="carSpec" style="font-size:12px;color:rgba(234,240,255,.75)"></span>
    </div>
  </div>

  <div id="hud">
    <div class="big" id="spd">0 km/h</div>
    <div class="small" id="dst">0.0 km</div>
    <div class="small" id="mode">DAY ¬∑ FOG: OFF</div>
    <div class="small" id="carName">CAR: -</div>
  </div>

  <div id="hint"></div>

  <script type="module">
    import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";

    const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
    const lerp=(a,b,t)=>a+(b-a)*t;

    function toast(msg){
      const el=document.getElementById('hint');
      el.textContent=msg;
      el.classList.add('on');
      clearTimeout(toast._t);
      toast._t=setTimeout(()=>el.classList.remove('on'), 900);
    }

    // ===== renderer =====
    const canvas=document.getElementById('gl');
    const renderer=new THREE.WebGLRenderer({
      canvas, antialias:true, alpha:false,
      powerPreference:"default",  // ‚úÖ Safari ÏïàÏ†ï Ïö∞ÏÑ†
      preserveDrawingBuffer:false
    });
    renderer.outputColorSpace = THREE.SRGBColorSpace;

    // ‚úÖ Ïª®ÌÖçÏä§Ìä∏ Î°úÏä§Ìä∏ ÎåÄÏùë (iOS/SafariÏóêÏÑú Í∞ÄÎÅî Î∞úÏÉù)
    canvas.addEventListener("webglcontextlost", (e)=>{
      e.preventDefault();
      toast("WebGL Ïª®ÌÖçÏä§Ìä∏Í∞Ä Ïû†Íπê ÎÅäÍ≤ºÏñ¥‚Ä¶ ÏÉàÎ°úÍ≥†Ïπ® Ìï¥Ï§ò!");
    }, false);

    const scene=new THREE.Scene();
    const camera=new THREE.PerspectiveCamera(65, 1, 0.1, 5000);

    // ===== env =====
    let isNight=false, fogOn=false;

    const hemi=new THREE.HemisphereLight(0xbcd7ff,0x101018,0.9);
    scene.add(hemi);

    const sun=new THREE.DirectionalLight(0xffffff,1.15);
    sun.position.set(80,160,70);
    scene.add(sun);

    const starGeo=new THREE.BufferGeometry();
    const starCount=1200;
    const starPos=new Float32Array(starCount*3);
    for(let i=0;i<starCount;i++){
      const r=900+Math.random()*1200;
      const th=Math.random()*Math.PI*2;
      const ph=Math.random()*Math.PI*0.45;
      starPos[i*3+0]=Math.cos(th)*Math.sin(ph)*r;
      starPos[i*3+1]=220+Math.cos(ph)*r*0.14;
      starPos[i*3+2]=Math.sin(th)*Math.sin(ph)*r;
    }
    starGeo.setAttribute('position', new THREE.BufferAttribute(starPos,3));
    const stars=new THREE.Points(starGeo, new THREE.PointsMaterial({
      color:0xffffff, size:1.1, sizeAttenuation:true,
      transparent:true, opacity:0.0
    }));
    scene.add(stars);

    function applyEnv(){
      if(!isNight){
        scene.background=new THREE.Color(0x9fc7ff);
        hemi.intensity=0.95; sun.intensity=1.15; sun.color.setHex(0xffffff);
        stars.material.opacity=0.0;
      }else{
        scene.background=new THREE.Color(0x050611);
        hemi.intensity=0.26; sun.intensity=0.35; sun.color.setHex(0xaac6ff);
        stars.material.opacity=0.9;
      }
      scene.fog = fogOn ? new THREE.Fog(isNight?0x050611:0x9fc7ff, 150, 900) : null;
      document.getElementById('mode').textContent=`${isNight?"NIGHT":"DAY"} ¬∑ FOG: ${fogOn?"ON":"OFF"}`;
    }
    applyEnv();

    // ===== cars =====
    const CAR_PROFILES=[
      { id:"ioniq5n", name:"ÌòÑÎåÄ ÏïÑÏù¥Ïò§Îãâ 5 N", topSpeed:150, accelTier:"Ìïò",   accelMul:0.72, color:0x3dd6ff, aero:1.06, grip:1.15 },
      { id:"furai",   name:"Mazda Furai",        topSpeed:250, accelTier:"Ï§ë",   accelMul:0.98, color:0xff5f2e, aero:1.02, grip:1.05 },
      { id:"huracan", name:"Ïö∞ÎùºÏπ∏ ÏóêÎ≥¥ Ïä§ÌååÏù¥Îçî", topSpeed:330, accelTier:"Ï§ëÏÉÅ", accelMul:1.12, color:0x2dd4bf, aero:0.98, grip:1.00 },
      { id:"agera",   name:"ÏïÑÏ†úÎùº RS",         topSpeed:400, accelTier:"ÏÉÅ",   accelMul:1.30, color:0x7c5cff, aero:0.95, grip:0.97 },
      { id:"devel",   name:"Îç∞Î≤® ÏãùÏä§Ìã¥",        topSpeed:552, accelTier:"ÏµúÏÉÅ", accelMul:1.62, color:0xffd166, aero:0.90, grip:0.92 },
    ];

    const sel=document.getElementById('carSel');
    CAR_PROFILES.forEach((c,i)=>{
      const opt=document.createElement('option');
      opt.value=c.id; opt.textContent=`${i+1}. ${c.name}`;
      sel.appendChild(opt);
    });

    function buildCar(p){
      const g=new THREE.Group();
      const bodyMat=new THREE.MeshStandardMaterial({ color:p.color, roughness:0.35, metalness:0.16 });
      const glassMat=new THREE.MeshStandardMaterial({ color:0x11162a, roughness:0.18, metalness:0.0 });
      const darkMat=new THREE.MeshStandardMaterial({ color:0x0f1220, roughness:0.9, metalness:0.0 });

      const wheelGeo=new THREE.CylinderGeometry(0.36,0.36,0.28,14);
      wheelGeo.rotateZ(Math.PI/2);
      const wheels=[];
      const addWheel=(x,y,z)=>{
        const w=new THREE.Mesh(wheelGeo,darkMat);
        w.position.set(x,y,z); g.add(w); wheels.push(w);
      };

      const headL=new THREE.SpotLight(0xdde9ff,0.0,95,Math.PI/9,0.55,1.0);
      headL.position.set(-0.55,0.65,1.85);
      headL.target.position.set(-0.55,0.2,38);
      g.add(headL); g.add(headL.target);

      const headR=headL.clone();
      headR.position.x=0.55;
      headR.target.position.x=0.55;
      g.add(headR); g.add(headR.target);

      const under=new THREE.PointLight(p.color,0.0,7.5);
      under.position.set(0,0.18,0.1);
      g.add(under);

      if(p.id==="ioniq5n"){
        g.add(new THREE.Mesh(new THREE.BoxGeometry(1.95,0.60,3.95), bodyMat)).position.set(0,0.58,0);
        g.add(new THREE.Mesh(new THREE.BoxGeometry(1.65,0.55,2.05), bodyMat)).position.set(0,1.03,-0.22);
        g.add(new THREE.Mesh(new THREE.BoxGeometry(1.50,0.42,1.70), glassMat)).position.set(0,1.06,-0.22);
        g.add(new THREE.Mesh(new THREE.BoxGeometry(1.35,0.12,0.55), darkMat)).position.set(0,1.14,-1.72);
        addWheel(-0.86,0.30, 1.42); addWheel(0.86,0.30, 1.42); addWheel(-0.86,0.30,-1.42); addWheel(0.86,0.30,-1.42);
      }else if(p.id==="furai"){
        g.add(new THREE.Mesh(new THREE.BoxGeometry(1.75,0.42,3.65), bodyMat)).position.set(0,0.48,0);
        const nose=new THREE.Mesh(new THREE.ConeGeometry(0.78,1.30,10), bodyMat);
        nose.rotation.x=Math.PI/2; nose.position.set(0,0.48,2.12); g.add(nose);
        g.add(new THREE.Mesh(new THREE.BoxGeometry(1.22,0.42,1.35), glassMat)).position.set(0,0.82,0.25);
        g.add(new THREE.Mesh(new THREE.BoxGeometry(0.10,0.58,1.25), darkMat)).position.set(0,1.08,-0.70);
        addWheel(-0.80,0.26, 1.28); addWheel(0.80,0.26, 1.28); addWheel(-0.80,0.26,-1.28); addWheel(0.80,0.26,-1.28);
      }else if(p.id==="huracan"){
        g.add(new THREE.Mesh(new THREE.BoxGeometry(1.88,0.38,3.35), bodyMat)).position.set(0,0.44,0);
        g.add(new THREE.Mesh(new THREE.BoxGeometry(1.78,0.22,1.45), bodyMat)).position.set(0,0.62,1.05);
        g.add(new THREE.Mesh(new THREE.BoxGeometry(1.38,0.35,1.05), glassMat)).position.set(0,0.80,-0.05);
        g.add(new THREE.Mesh(new THREE.BoxGeometry(1.78,0.22,1.20), darkMat)).position.set(0,0.62,-1.16);
        addWheel(-0.87,0.25, 1.15); addWheel(0.87,0.25, 1.15); addWheel(-0.87,0.25,-1.15); addWheel(0.87,0.25,-1.15);
      }else if(p.id==="agera"){
        g.add(new THREE.Mesh(new THREE.BoxGeometry(1.88,0.38,3.85), bodyMat)).position.set(0,0.44,0);
        const nose=new THREE.Mesh(new THREE.ConeGeometry(0.72,1.18,12), bodyMat);
        nose.rotation.x=Math.PI/2; nose.position.set(0,0.44,2.40); g.add(nose);
        g.add(new THREE.Mesh(new THREE.BoxGeometry(1.28,0.40,1.30), glassMat)).position.set(0,0.82,0.26);
        g.add(new THREE.Mesh(new THREE.BoxGeometry(1.92,0.10,0.60), darkMat)).position.set(0,0.98,-1.95);
        g.add(new THREE.Mesh(new THREE.BoxGeometry(0.12,0.35,0.12), darkMat)).position.set(-0.78,0.83,-1.78);
        g.add(new THREE.Mesh(new THREE.BoxGeometry(0.12,0.35,0.12), darkMat)).position.set( 0.78,0.83,-1.78);
        addWheel(-0.87,0.25, 1.38); addWheel(0.87,0.25, 1.38); addWheel(-0.87,0.25,-1.38); addWheel(0.87,0.25,-1.38);
      }else{
        g.add(new THREE.Mesh(new THREE.BoxGeometry(2.08,0.42,4.45), bodyMat)).position.set(0,0.48,0);
        const nose=new THREE.Mesh(new THREE.ConeGeometry(0.88,1.60,14), bodyMat);
        nose.rotation.x=Math.PI/2; nose.position.set(0,0.48,2.92); g.add(nose);
        g.add(new THREE.Mesh(new THREE.BoxGeometry(1.38,0.45,1.40), glassMat)).position.set(0,0.86,0.18);
        g.add(new THREE.Mesh(new THREE.BoxGeometry(2.05,0.28,1.35), darkMat)).position.set(0,0.62,-2.10);
        addWheel(-0.96,0.26, 1.60); addWheel(0.96,0.26, 1.60); addWheel(-0.96,0.26,-1.60); addWheel(0.96,0.26,-1.60);
      }

      g.userData={ wheels, headL, headR, under };
      return g;
    }

    let currentCar = CAR_PROFILES[0];
    let car = buildCar(currentCar);
    scene.add(car);

    function applyCar(p){
      currentCar=p;
      scene.remove(car);
      car=buildCar(p);
      scene.add(car);
      document.getElementById('carName').textContent=`CAR: ${p.name}`;
      document.getElementById('carSpec').textContent=`ÏµúÍ≥†ÏÜçÎèÑ ${p.topSpeed} km/h ¬∑ Í∞ÄÏÜç ${p.accelTier}`;
      toast(`${p.name} ÏÑ†ÌÉùÎê®`);
    }

    sel.value=currentCar.id;
    applyCar(currentCar);

    sel.addEventListener('change', ()=>{
      const p = CAR_PROFILES.find(x=>x.id===sel.value) || CAR_PROFILES[0];
      applyCar(p);
      state.speed = Math.min(state.speed, (p.topSpeed/3.6)*0.65);
    });

    // ===== road (Uint16 index: Safari ÏïàÏ†Ñ) =====
    const ROAD_WIDTH=10.0;
    const SHOULDER_W=ROAD_WIDTH*2.25;
    const N=240;
    const SPACING=7.0;

    const cx=new Float32Array(N);
    const cz=new Float32Array(N);
    const yawArr=new Float32Array(N);

    let yaw=0, curv=0, curvTarget=0, curvBlend=0;
    function pickCurvTarget(){
      const base=(Math.random()*2-1)*0.0012;
      const spice=(Math.random()<0.22)?(Math.random()*2-1)*0.0024:0;
      curvTarget=clamp(base+spice,-0.0030,0.0030);
    }
    pickCurvTarget();

    function initRoad(){
      yaw=0; curv=0; curvBlend=0; pickCurvTarget();
      let x=0,z=0;
      for(let i=0;i<N;i++){
        cx[i]=x; cz[i]=z; yawArr[i]=yaw;
        x += Math.sin(yaw)*SPACING;
        z += -Math.cos(yaw)*SPACING;
        curvBlend += 0.004;
        if(curvBlend>=1){ curvBlend=0; pickCurvTarget(); }
        curv = lerp(curv, curvTarget, 0.02);
        yaw = clamp(yaw + curv*SPACING, -1.1, 1.1);
      }
    }
    initRoad();

    function makeRibbonGeo(width){
      const geo=new THREE.BufferGeometry();
      geo.userData.width=width;

      const vCount=N*2;
      geo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(vCount*3),3));
      geo.setAttribute('normal',   new THREE.BufferAttribute(new Float32Array(vCount*3),3));
      geo.setAttribute('uv',       new THREE.BufferAttribute(new Float32Array(vCount*2),2));

      // ‚úÖ Uint16Array ÏÇ¨Ïö© (NÏù¥ ÏûëÏïÑÏÑú Ï∂©Î∂Ñ)
      const idx=new Uint16Array((N-1)*6);
      let k=0;
      for(let i=0;i<N-1;i++){
        const a=i*2, b=i*2+1, c=(i+1)*2, d=(i+1)*2+1;
        idx[k++]=a; idx[k++]=c; idx[k++]=b;
        idx[k++]=b; idx[k++]=c; idx[k++]=d;
      }
      geo.setIndex(new THREE.BufferAttribute(idx,1));
      return geo;
    }

    function makeDashTexture(){
      const c=document.createElement('canvas');
      c.width=64; c.height=16;
      const g=c.getContext('2d');
      g.clearRect(0,0,64,16);
      g.fillStyle="#fff";
      g.fillRect(0,6,28,4);
      g.fillRect(38,6,18,4);
      const tex=new THREE.CanvasTexture(c);
      tex.wrapS=tex.wrapT=THREE.RepeatWrapping;
      tex.repeat.set(1,40);
      tex.anisotropy=1;
      return tex;
    }

    const matRoad=new THREE.MeshStandardMaterial({ color:0x2b2f3a, roughness:0.95 });
    const matShoulder=new THREE.MeshStandardMaterial({ color:0x1b1e26, roughness:1.0 });
    const matLine=new THREE.MeshStandardMaterial({ color:0xe7ecff, roughness:0.35 });

    const dashTex=makeDashTexture();
    const matDash=new THREE.MeshBasicMaterial({ color:0xffffff, map:dashTex, transparent:true, opacity:0.95 });

    const geoShoulder=makeRibbonGeo(SHOULDER_W);
    const geoRoad=makeRibbonGeo(ROAD_WIDTH);
    const geoLC=makeRibbonGeo(0.22);
    const geoLL=makeRibbonGeo(0.22);
    const geoLR=makeRibbonGeo(0.22);

    const shoulder=new THREE.Mesh(geoShoulder, matShoulder); shoulder.position.y=0.0; scene.add(shoulder);
    const road=new THREE.Mesh(geoRoad, matRoad); road.position.y=0.02; scene.add(road);
    const lineC=new THREE.Mesh(geoLC, matDash); lineC.position.y=0.035; scene.add(lineC);
    const lineL=new THREE.Mesh(geoLL, matLine); lineL.position.y=0.035; scene.add(lineL);
    const lineR=new THREE.Mesh(geoLR, matLine); lineR.position.y=0.035; scene.add(lineR);

    function writeRibbon(geo, offsetX, offX, offZ){
      const width=geo.userData.width;
      const pos=geo.attributes.position.array;
      const nor=geo.attributes.normal.array;
      const uv=geo.attributes.uv.array;
      const half=width*0.5;

      for(let i=0;i<N;i++){
        const y=yawArr[i];
        const rx=Math.cos(y), rz=Math.sin(y);
        const x=cx[i]-offX;
        const z=cz[i]-offZ;

        const lx=x+rx*(-half+offsetX);
        const lz=z+rz*(-half+offsetX);
        const rxp=x+rx*( half+offsetX);
        const rzp=z+rz*( half+offsetX);

        const p=i*2*3;
        pos[p+0]=lx;  pos[p+1]=0; pos[p+2]=lz;
        pos[p+3]=rxp; pos[p+4]=0; pos[p+5]=rzp;

        nor[p+0]=0; nor[p+1]=1; nor[p+2]=0;
        nor[p+3]=0; nor[p+4]=1; nor[p+5]=0;

        const v=i/(N-1);
        const t=i*2*2;
        uv[t+0]=0; uv[t+1]=v*22;
        uv[t+2]=1; uv[t+3]=v*22;
      }

      geo.attributes.position.needsUpdate=true;
      geo.attributes.normal.needsUpdate=true;
      geo.attributes.uv.needsUpdate=true;
      geo.computeBoundingSphere();
    }

    // ===== physics =====
    const keys=new Set();
    const state={ speed:0, dist:0, laneX:0, laneV:0 };

    function powerCurve(tier,r){
      r=clamp(r,0,1.2);
      if(tier==="Ìïò")   return Math.pow(1-r,1.55)+0.08;
      if(tier==="Ï§ë")   return Math.pow(1-r,1.25)+0.10;
      if(tier==="Ï§ëÏÉÅ") return Math.pow(1-r,1.05)+0.12;
      if(tier==="ÏÉÅ")   return Math.pow(1-r,0.88)+0.14;
      return Math.pow(1-r,0.62)+0.18;
    }

    let consume=0;
    function advanceRoad(dz){
      consume += dz;
      while(consume >= SPACING){
        consume -= SPACING;

        cx.copyWithin(0,1);
        cz.copyWithin(0,1);
        yawArr.copyWithin(0,1);

        const lastX=cx[N-2], lastZ=cz[N-2], lastYaw=yawArr[N-2];

        curvBlend += 0.004;
        if(curvBlend>=1){ curvBlend=0; pickCurvTarget(); }
        curv = lerp(curv, curvTarget, 0.02);

        const newYaw=clamp(lastYaw + curv*SPACING, -1.1, 1.1);
        cx[N-1]=lastX + Math.sin(newYaw)*SPACING;
        cz[N-1]=lastZ + -Math.cos(newYaw)*SPACING;
        yawArr[N-1]=newYaw;
      }

      const y0=yawArr[0];
      return {
        offX: Math.sin(y0)*consume,
        offZ: -Math.cos(y0)*consume
      };
    }

    // ===== input (single) =====
    addEventListener('keydown',(e)=>{
      keys.add(e.code);

      if(!e.repeat && e.code==="KeyF"){ fogOn=!fogOn; applyEnv(); toast(`FOG ${fogOn?"ON":"OFF"}`); }
      if(!e.repeat && e.code==="KeyT"){ isNight=!isNight; applyEnv(); toast(isNight?"NIGHT":"DAY"); }
      if(!e.repeat && e.code==="KeyR"){ resetAll(); toast("RESET"); }

      if(!e.repeat && e.code.startsWith("Digit")){
        const n=parseInt(e.code.slice(5),10);
        if(n>=1 && n<=5){
          sel.value=CAR_PROFILES[n-1].id;
          sel.dispatchEvent(new Event('change'));
        }
      }
    });
    addEventListener('keyup',(e)=>keys.delete(e.code));

    function resetAll(){
      state.speed=0; state.dist=0; state.laneX=0; state.laneV=0;
      initRoad(); consume=0;
    }

    // ===== resize (visualViewport ÎåÄÏùë) =====
    function doResize(){
      const w = Math.floor((visualViewport?.width ?? innerWidth));
      const h = Math.floor((visualViewport?.height ?? innerHeight));
      const dpr = Math.min(devicePixelRatio, 2);

      canvas.style.width = w + "px";
      canvas.style.height = h + "px";

      renderer.setPixelRatio(dpr);
      renderer.setSize(w, h, true);

      camera.aspect = w/h;
      camera.updateProjectionMatrix();
    }
    addEventListener('resize', doResize);
    if (visualViewport) visualViewport.addEventListener('resize', doResize);
    doResize();

    // ===== camera =====
    camera.position.set(0,6,16);

    // ===== loop =====
    let last=performance.now();
    toast("WÎ°ú Ï∂úÎ∞ú! 1~5 Ï∞® Î≥ÄÍ≤Ω üöó");

    function tick(){
      const now=performance.now();
      const dt=Math.min(0.033,(now-last)/1000);
      last=now;

      const throttle = keys.has("KeyW")?1:0;
      const brakeIn  = keys.has("KeyS")?1:0;
      const steerIn  = (keys.has("KeyD")?1:0) - (keys.has("KeyA")?1:0);
      const boost    = keys.has("ShiftLeft") || keys.has("ShiftRight");

      const maxV=(currentCar.topSpeed/3.6)*(boost?1.08:1.0);
      const r=state.speed/Math.max(0.1,maxV);
      const engine=powerCurve(currentCar.accelTier,r);
      const accelBase=14.0*currentCar.accelMul*(boost?1.20:1.0)*engine;

      const brake=18.0;
      const aeroDrag=(0.20+state.speed*0.018)*currentCar.aero;

      if(throttle) state.speed += accelBase*dt;
      else state.speed -= aeroDrag*dt;
      if(brakeIn) state.speed -= brake*dt;

      state.speed=clamp(state.speed,0,maxV);

      const laneMax=ROAD_WIDTH/2 - 1.05;
      const steerPower=(7.2 + state.speed*0.22)/currentCar.grip;

      state.laneV += steerIn*steerPower*dt;
      state.laneV *= Math.pow(0.10, dt);
      state.laneX += state.laneV*dt;

      // curve push
      const curvePush = curv * state.speed * state.speed * 0.55 * (1.0/currentCar.grip);
      state.laneX += curvePush*dt;

      const over=Math.max(0,Math.abs(state.laneX)-laneMax);
      if(over>0){
        state.laneX -= Math.sign(state.laneX)*over*2.7*dt;
        state.laneV *= 0.6;
      }
      state.laneX=clamp(state.laneX,-laneMax-0.6,laneMax+0.6);

      const dz=state.speed*dt;
      state.dist += dz;

      const {offX,offZ}=advanceRoad(dz);

      writeRibbon(geoShoulder,0,offX,offZ);
      writeRibbon(geoRoad,0,offX,offZ);
      writeRibbon(geoLC,0,offX,offZ);
      writeRibbon(geoLL,-ROAD_WIDTH/2+0.35,offX,offZ);
      writeRibbon(geoLR, ROAD_WIDTH/2-0.35,offX,offZ);

      // dashed scroll
      dashTex.offset.y += dt*(0.35 + state.speed*0.006);

      // car pose
      const carIdx=6;
      const y=yawArr[carIdx];
      const rx=Math.cos(y), rz=Math.sin(y);
      const fx=Math.sin(y), fz=-Math.cos(y);

      const baseX=cx[carIdx]-offX;
      const baseZ=cz[carIdx]-offZ;

      const carX=baseX + rx*state.laneX + fx*10.0;
      const carZ=baseZ + rz*state.laneX + fz*10.0;

      car.position.set(carX,0,carZ);
      car.rotation.y = y + (-steerIn*0.10);

      const spin=state.speed*dt*2.6;
      for(const w of car.userData.wheels) w.rotation.x -= spin;

      const headI=isNight?2.2:0.0;
      car.userData.headL.intensity=headI;
      car.userData.headR.intensity=headI;
      car.userData.under.intensity=isNight?0.65:0.0;

      // camera follow
      const kmh=state.speed*3.6;
      const speed01=clamp((kmh-30)/260,0,1);
      const camLow=lerp(6.0,4.6,speed01);
      const camBack=lerp(16.0,13.2,speed01);
      const camLook=lerp(30.0,40.0,speed01);

      camera.position.lerp(new THREE.Vector3(carX, camLow, carZ+camBack), 1 - Math.pow(0.001, dt));
      camera.lookAt(carX*0.65, 1.25, carZ-camLook);

      document.getElementById('spd').textContent = `${Math.round(kmh)} km/h`;
      document.getElementById('dst').textContent = `${(state.dist/1000).toFixed(1)} km`;

      renderer.render(scene,camera);
      requestAnimationFrame(tick);
    }
    tick();
  </script>
</body>
</html>
