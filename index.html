<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>CarLoad Rebuild v2.1</title>
  <style>
    html, body { margin:0; padding:0; overflow:hidden; background:#05070e; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    #ui{
      position:fixed; left:12px; top:12px; z-index:10; width: 360px;
      background: rgba(10,12,18,0.65); color:#e9eefc;
      border:1px solid rgba(255,255,255,0.12);
      border-radius:14px; padding:12px 12px 10px;
      backdrop-filter: blur(10px);
      box-shadow: 0 8px 30px rgba(0,0,0,0.35);
    }
    #ui h1{ font-size:14px; margin:0 0 8px; font-weight:800; }
    #row{ display:flex; gap:8px; align-items:center; margin:6px 0; flex-wrap: wrap; }
    select, button, label{
      background: rgba(255,255,255,0.08); color:#e9eefc;
      border: 1px solid rgba(255,255,255,0.14);
      border-radius: 10px; padding: 8px 10px; outline:none;
      font-size: 13px;
    }
    label{ display:flex; align-items:center; gap:8px; padding: 7px 10px; user-select:none; }
    input[type="checkbox"]{ transform: translateY(1px); }
    input[type="range"]{ width: 120px; }
    button { cursor:pointer; }
    button:hover { background: rgba(255,255,255,0.12); }
    .muted{ color: rgba(233,238,252,0.75); font-size:12px; line-height:1.35; }
    #stats{ margin-top:8px; font-size:12px; line-height:1.5; }
    #hud{
      position:fixed; right:12px; top:12px; z-index:10;
      background: rgba(10,12,18,0.55); color:#e9eefc;
      border:1px solid rgba(255,255,255,0.12);
      border-radius:14px; padding:10px 12px;
      backdrop-filter: blur(10px);
      min-width: 220px;
      box-shadow: 0 8px 30px rgba(0,0,0,0.35);
      font-size:12px;
      line-height:1.45;
      text-align:right;
    }
    #hint{
      position:fixed; left:50%; bottom:14px; transform:translateX(-50%);
      z-index:10; color: rgba(233,238,252,0.85);
      font-size:12px;
      background: rgba(10,12,18,0.35);
      border:1px solid rgba(255,255,255,0.10);
      border-radius: 999px;
      padding: 8px 14px;
      backdrop-filter: blur(10px);
      user-select:none;
    }
    canvas{ display:block; }
  </style>
</head>
<body>
  <div id="ui">
    <h1>CarLoad Rebuild v2.1</h1>
    <div id="row">
      <select id="carSelect"></select>
      <button id="resetBtn">리셋</button>
      <button id="pauseBtn">일시정지</button>
      <label title="체감이 반대면 켜봐">
        <input id="invertSteer" type="checkbox" />
        조향 반전
      </label>
      <label title="도로 폭을 조절합니다">
        도로 폭
        <input id="roadWidth" type="range" min="8" max="22" step="1" value="10" />
        <span id="roadWidthVal" class="muted" style="margin-left:2px;">10</span>
      </label>
    </div>
    <div class="muted">
      조작: <b>W</b>가속 / <b>S</b>브레이크 / <b>A,D</b>조향 / <b>Space</b>핸드브레이크 / <b>R</b>리셋<br>
      토글: <b>L</b>라이트 / <b>P</b>낮·밤 / <b>M</b>안개
    </div>
    <div id="stats"></div>
  </div>

  <div id="hud">
    <div><b id="hudCar">-</b></div>
    <div>속도: <b id="hudSpeed">0</b> km/h</div>
    <div>안전: <b id="hudSafe">OK</b></div>
    <div>조향: <b id="hudSteer">A=← / D=→</b></div>
    <div>라이트: <b id="hudLight">OFF</b></div>
    <div>시간: <b id="hudTime">NIGHT</b></div>
    <div>안개: <b id="hudFog">ON</b></div>
  </div>

  <div id="hint">무한 도로 + (L)라이트 (P)낮밤 (M)안개 + 도로폭 조절 + 조향 질질 끌림 개선</div>

<script type="module">
import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js";

// ===== 안전 유틸 =====
const EPS = 1e-8;
function isBad(n){ return !Number.isFinite(n) || Number.isNaN(n); }
function safe(n, fallback=0){ return isBad(n) ? fallback : n; }
function clamp(x,a,b){ x = safe(x,a); return Math.max(a, Math.min(b, x)); }
function lerp(a,b,t){ return a + (b-a)*clamp(t,0,1); }
function vecSafe(v, fallback=new THREE.Vector3()){
  if (!v || isBad(v.x) || isBad(v.y) || isBad(v.z)) return fallback.clone();
  return v;
}
function expLerpVec(out, target, lambda, dt){
  dt = clamp(dt, 0, 0.05);
  const t = 1 - Math.exp(-lambda*dt);
  out.lerp(target, t);
}

// ===== 렌더/씬 =====
const canvas = document.createElement("canvas");
document.body.appendChild(canvas);

const renderer = new THREE.WebGLRenderer({ canvas, antialias:true });
renderer.setPixelRatio(Math.min(window.devicePixelRatio||1, 2));
renderer.setSize(window.innerWidth, window.innerHeight, true);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.05;

const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x0a0f1e, 0.0075);

const camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.1, 2000);
camera.position.set(0, 7, 14);

// ===== 스카이(밤/낮 토글용) =====
const sky = (()=>{
  const geo = new THREE.SphereGeometry(950, 32, 16);
  const mat = new THREE.ShaderMaterial({
    side: THREE.BackSide,
    uniforms: {
      topColor:{ value:new THREE.Color(0x16224a) },
      midColor:{ value:new THREE.Color(0x0a1026) },
      botColor:{ value:new THREE.Color(0x05070e) },
      offset:{ value:0.08 },
      exponent:{ value:0.8 }
    },
    vertexShader:`varying vec3 vWorldPos; void main(){ vec4 wpos=modelMatrix*vec4(position,1.0); vWorldPos=wpos.xyz; gl_Position=projectionMatrix*viewMatrix*wpos; }`,
    fragmentShader:`varying vec3 vWorldPos; uniform vec3 topColor, midColor, botColor; uniform float offset, exponent; void main(){ float h=normalize(vWorldPos).y; float t=pow(max(h+offset,0.0),exponent); vec3 col=mix(botColor, midColor, smoothstep(0.0,0.45,t)); col=mix(col, topColor, smoothstep(0.35,1.0,t)); gl_FragColor=vec4(col,1.0);} `
  });
  const m = new THREE.Mesh(geo, mat);
  m.frustumCulled=false;
  scene.add(m);
  return m;
})();

// ===== 바닥 =====
const ground = new THREE.Mesh(
  new THREE.PlaneGeometry(2600, 2600, 1, 1),
  new THREE.MeshStandardMaterial({ color:0x0b1224, roughness:1.0, metalness:0.0 })
);
ground.rotation.x = -Math.PI/2;
ground.position.y = -0.02;
ground.receiveShadow = true;
scene.add(ground);

// ===== 라이트 =====
scene.add(new THREE.AmbientLight(0x9fb0ff, 0.20));

const moon = new THREE.DirectionalLight(0xcfe0ff, 0.85);
moon.position.set(120, 180, 40);
moon.castShadow = true;
moon.shadow.mapSize.set(2048, 2048);
moon.shadow.camera.near = 10;
moon.shadow.camera.far  = 520;
moon.shadow.camera.left = -160;
moon.shadow.camera.right= 160;
moon.shadow.camera.top  = 160;
moon.shadow.camera.bottom=-160;
scene.add(moon);

const fill = new THREE.DirectionalLight(0x6ea2ff, 0.25);
fill.position.set(-80, 80, -120);
scene.add(fill);

// ===== 자동차 모델 (8대) + 헤드라이트(SpotLight) =====
function makeCarModel(kind, color=0xffffff){
  const g = new THREE.Group();
  const bodyMat = new THREE.MeshStandardMaterial({ color, roughness:0.38, metalness:0.18 });
  const glassMat= new THREE.MeshStandardMaterial({ color:0x9fb8ff, roughness:0.15, metalness:0.05, transparent:true, opacity:0.35 });
  const darkMat = new THREE.MeshStandardMaterial({ color:0x0e1220, roughness:0.9, metalness:0.05 });
  const rimMat  = new THREE.MeshStandardMaterial({ color:0x22283a, roughness:0.6, metalness:0.25 });
  const lightMat= new THREE.MeshStandardMaterial({ color:0xdde6ff, roughness:0.25, metalness:0.0, emissive:0x2a395a, emissiveIntensity:0.7 });

  const wheelGeo = new THREE.CylinderGeometry(0.42, 0.42, 0.28, 14);
  function addWheel(x,z){
    const w = new THREE.Mesh(wheelGeo, rimMat);
    w.rotation.z = Math.PI/2;
    w.position.set(x, 0.42, z);
    w.castShadow = true; w.receiveShadow = true;
    g.add(w);
    return w;
  }

  let body, cabin, nose, spoiler;

  if (kind === "hatch"){
    body = new THREE.Mesh(new THREE.BoxGeometry(2.1,0.7,4.0), bodyMat); body.position.set(0,0.75,0);
    cabin= new THREE.Mesh(new THREE.BoxGeometry(1.7,0.65,1.9), glassMat); cabin.position.set(0,1.15,-0.25);
  } else if (kind === "sedan"){
    body = new THREE.Mesh(new THREE.BoxGeometry(2.0,0.65,4.4), bodyMat); body.position.set(0,0.75,0);
    cabin= new THREE.Mesh(new THREE.BoxGeometry(1.6,0.6,2.1), glassMat); cabin.position.set(0,1.12,-0.25);
    nose = new THREE.Mesh(new THREE.BoxGeometry(1.8,0.35,1.3), bodyMat); nose.position.set(0,0.62,1.65);
  } else if (kind === "super"){
    body = new THREE.Mesh(new THREE.BoxGeometry(2.15,0.55,4.2), bodyMat); body.position.set(0,0.65,0);
    cabin= new THREE.Mesh(new THREE.BoxGeometry(1.6,0.45,1.7), glassMat); cabin.position.set(0,0.95,-0.3);
    spoiler=new THREE.Mesh(new THREE.BoxGeometry(1.2,0.12,0.35), darkMat); spoiler.position.set(0,1.05,-1.95);
  } else if (kind === "hyper"){
    body = new THREE.Mesh(new THREE.BoxGeometry(2.25,0.52,4.6), bodyMat); body.position.set(0,0.62,0);
    cabin= new THREE.Mesh(new THREE.BoxGeometry(1.5,0.42,1.6), glassMat); cabin.position.set(0,0.92,-0.45);
    nose = new THREE.Mesh(new THREE.BoxGeometry(2.0,0.22,1.5), bodyMat); nose.position.set(0,0.58,2.0);
    spoiler=new THREE.Mesh(new THREE.BoxGeometry(1.35,0.10,0.55), darkMat); spoiler.position.set(0,1.02,-2.25);
  } else if (kind === "truck"){
    body = new THREE.Mesh(new THREE.BoxGeometry(2.25,0.9,4.6), bodyMat); body.position.set(0,0.95,-0.2);
    cabin= new THREE.Mesh(new THREE.BoxGeometry(1.9,0.85,2.0), glassMat); cabin.position.set(0,1.45,0.85);
    nose = new THREE.Mesh(new THREE.BoxGeometry(2.1,0.45,1.2), bodyMat); nose.position.set(0,0.85,2.25);
  } else {
    body = new THREE.Mesh(new THREE.BoxGeometry(2.0,0.65,4.0), bodyMat); body.position.set(0,0.75,0);
    cabin= new THREE.Mesh(new THREE.BoxGeometry(1.6,0.6,1.8), glassMat); cabin.position.set(0,1.1,-0.25);
  }

  [body,cabin,nose,spoiler].forEach(m=>{
    if(!m) return;
    m.castShadow = true; m.receiveShadow = true;
    g.add(m);
  });

  // 헤드라이트 메쉬(시각)
  const headL = new THREE.Mesh(new THREE.BoxGeometry(0.35,0.20,0.10), lightMat);
  headL.position.set(-0.75, 0.72, 2.15);
  const headR = headL.clone(); headR.position.x = +0.75;
  g.add(headL, headR);

  const wheelZFront = (kind==="truck") ? 1.75 : 1.55;
  const wheelZBack  = (kind==="hyper") ? -1.75 : -1.55;
  const wheelX      = (kind==="truck") ? 1.05 : 0.98;

  const wheels = [
    addWheel(-wheelX, wheelZFront),
    addWheel(+wheelX, wheelZFront),
    addWheel(-wheelX, wheelZBack),
    addWheel(+wheelX, wheelZBack),
  ];

  const skirt = new THREE.Mesh(new THREE.BoxGeometry(2.05,0.22,3.6), darkMat);
  skirt.position.set(0,0.50,0);
  skirt.castShadow = true; skirt.receiveShadow = true;
  g.add(skirt);

  // 실제 빛(SpotLight) — 토글로 켬/끔
  const spot = new THREE.SpotLight(0xddeaff, 0, 32, Math.PI/5, 0.35, 1.8);
  spot.position.set(0, 0.85, 2.55);
  spot.target.position.set(0, 0.45, 8);
  spot.castShadow = true;
  g.add(spot);
  g.add(spot.target);

  g.userData = { wheels, headLight: spot, headMeshes: [headL, headR] };
  return g;
}

const CAR_PRESETS = [
  { id:"ioniq5n", name:"Hyundai IONIQ 5 N",  kind:"hatch", color:0x8ad3ff, vmax:150, accel:7.5,  brake:11.0, steer:1.10, grip:0.95 },
  { id:"furai",   name:"Mazda Furai",        kind:"super", color:0xff5a7a, vmax:250, accel:10.0, brake:12.5, steer:1.25, grip:1.05 },
  { id:"huracan", name:"Huracán EVO Spyder", kind:"super", color:0x9cff68, vmax:330, accel:12.5, brake:13.5, steer:1.18, grip:1.08 },
  { id:"agera",   name:"Agera RS",           kind:"hyper", color:0xffd36e, vmax:400, accel:14.0, brake:14.5, steer:1.10, grip:1.02 },
  { id:"devel",   name:"Devel Sixteen",      kind:"hyper", color:0xcaa7ff, vmax:552, accel:18.0, brake:15.0, steer:0.98, grip:0.98 },
  { id:"gt3",     name:"911 GT3-ish",        kind:"sedan", color:0xa6b8ff, vmax:310, accel:12.0, brake:14.0, steer:1.28, grip:1.12 },
  { id:"rally",   name:"Rally Hatch",        kind:"hatch", color:0xffa06e, vmax:220, accel:11.0, brake:12.5, steer:1.35, grip:1.18 },
  { id:"pickup",  name:"Night Pickup",       kind:"truck", color:0x7cffc7, vmax:180, accel:8.8,  brake:12.0, steer:0.95, grip:0.92 },
];

function mpsFromKmh(kmh){ return kmh / 3.6; }
function kmhFromMps(mps){ return mps * 3.6; }

// ===== 무한 도로(청크 재활용) =====
const ROAD = {
  width: 10,
  y: 0.0,
  step: 2.0,
  curvatureLimit: 0.010,
  bankMax: 0.22,
  chunkLength: 60,
  chunks: 18,
};

// 도로 벽(가드레일) 설정
const WALL = {
  height: 1.35,      // 벽 높이
  lift: 0.02,        // 도로 위로 살짝 띄우기(깜빡임 방지)
  opacity: 0.95,
  hitBounce: 0.22,   // 부딪힐 때 측면 속도 반사 비율
  hitDamp: 0.85      // 부딪힐 때 측면 속도 감쇠
};
ROAD.rowsPerChunk = Math.floor(ROAD.chunkLength / ROAD.step) + 1;

let roadSeed = 1337;
function hash01(n){ const x = Math.sin(n * 127.1 + roadSeed * 0.013) * 43758.5453; return x - Math.floor(x); }
function noise1D(t){ const i=Math.floor(t), f=t-i; const a=hash01(i), b=hash01(i+1); const u=f*f*(3-2*f); return a+(b-a)*u; }

const track = { heading:0, x:0, z:0, s:0 };
function resetTrack(){ track.heading=0; track.x=0; track.z=0; track.s=0; }
function advanceTrack(ds){
  const sNext = track.s + ds;
  const t = sNext * 0.035;
  const n  = (noise1D(t) - 0.5) * 2.0;
  const n2 = (noise1D(t*0.37 + 40.0) - 0.5) * 2.0;
  let curvature = (n*0.65 + n2*0.35) * ROAD.curvatureLimit;
  curvature = clamp(curvature, -ROAD.curvatureLimit, ROAD.curvatureLimit);
  track.heading += curvature * ds;
  track.heading = safe(track.heading, 0);
  track.x += Math.sin(track.heading) * ds;
  track.z += Math.cos(track.heading) * ds;
  track.x = safe(track.x, 0);
  track.z = safe(track.z, 0);
  track.s = sNext;
  const bank = clamp(curvature * 220.0, -ROAD.bankMax, ROAD.bankMax);
  return { pos:new THREE.Vector3(track.x, ROAD.y, track.z), heading:track.heading, bank, s:track.s };
}

function makeRoadChunk(){
  const verts = ROAD.rowsPerChunk * 2;
  const positions = new Float32Array(verts * 3);
  const normals   = new Float32Array(verts * 3);
  const uvs       = new Float32Array(verts * 2);
  const indices = [];
  for (let i=0; i<ROAD.rowsPerChunk-1; i++){
    const a=i*2, b=i*2+1, c=(i+1)*2, d=(i+1)*2+1;
    indices.push(a,b,c, b,d,c);
  }
  const geom = new THREE.BufferGeometry();
  geom.setAttribute("position", new THREE.BufferAttribute(positions,3));
  geom.setAttribute("normal",   new THREE.BufferAttribute(normals,3));
  geom.setAttribute("uv",       new THREE.BufferAttribute(uvs,2));
  geom.setIndex(indices);

  const roadMat = new THREE.MeshStandardMaterial({ color:0x1a2134, roughness:0.92, metalness:0.02 });
  const roadMesh = new THREE.Mesh(geom, roadMat);
  roadMesh.receiveShadow = true;

  const lineGeom = new THREE.BufferGeometry();
  const linePos = new Float32Array(ROAD.rowsPerChunk * 3);
  lineGeom.setAttribute("position", new THREE.BufferAttribute(linePos,3));
  const lineMat = new THREE.LineDashedMaterial({ color:0xf3f7ff, dashSize:2.2, gapSize:2.2, transparent:true, opacity:0.65 });
  const centerLine = new THREE.Line(lineGeom, lineMat);

  // ===== 벽(가드레일) =====
  // 각 샘플마다 (바닥/윗면) 2점 → 전체는 ROAD.rowsPerChunk*2 버텍스
  function makeWallMesh(){
    const wVerts = ROAD.rowsPerChunk * 2;
    const wPos = new Float32Array(wVerts * 3);
    const wNor = new Float32Array(wVerts * 3);
    const wUv  = new Float32Array(wVerts * 2);
    const wIdx = [];
    for (let i=0; i<ROAD.rowsPerChunk-1; i++){
      const a=i*2, b=i*2+1, c=(i+1)*2, d=(i+1)*2+1;
      wIdx.push(a,b,c, b,d,c);
    }
    const g = new THREE.BufferGeometry();
    g.setAttribute("position", new THREE.BufferAttribute(wPos,3));
    g.setAttribute("normal",   new THREE.BufferAttribute(wNor,3));
    g.setAttribute("uv",       new THREE.BufferAttribute(wUv,2));
    g.setIndex(wIdx);

    const m = new THREE.MeshStandardMaterial({
      color: 0x0f1627,
      roughness: 0.85,
      metalness: 0.10,
      transparent: true,
      opacity: WALL.opacity,
      side: THREE.DoubleSide
    });

    const mesh = new THREE.Mesh(g, m);
    mesh.castShadow = true;
    mesh.receiveShadow = true;
    return mesh;
  }

  const leftWall  = makeWallMesh();
  const rightWall = makeWallMesh();

  const g = new THREE.Group();
  g.add(roadMesh);
  g.add(centerLine);
  g.add(leftWall);
  g.add(rightWall);
  g.userData = { roadMesh, centerLine, leftWall, rightWall };
  return g;
}

function updateChunkGeometry(chunk, samples){
  const { roadMesh, centerLine, leftWall, rightWall } = chunk.userData;
  const posAttr = roadMesh.geometry.getAttribute("position");
  const norAttr = roadMesh.geometry.getAttribute("normal");
  const uvAttr  = roadMesh.geometry.getAttribute("uv");
  const lineAttr= centerLine.geometry.getAttribute("position");

  const lwPos = leftWall.geometry.getAttribute("position");
  const lwNor = leftWall.geometry.getAttribute("normal");
  const lwUv  = leftWall.geometry.getAttribute("uv");

  const rwPos = rightWall.geometry.getAttribute("position");
  const rwNor = rightWall.geometry.getAttribute("normal");
  const rwUv  = rightWall.geometry.getAttribute("uv");

  for (let i=0; i<samples.length; i++){
    const p = samples[i].pos;
    const yaw = samples[i].heading;
    const bank = samples[i].bank;

    const forward = new THREE.Vector3(Math.sin(yaw), 0, Math.cos(yaw));
    const side = new THREE.Vector3(-forward.z, 0, forward.x);
    const up = new THREE.Vector3(0,1,0);

    const bankQuat = new THREE.Quaternion().setFromAxisAngle(forward, bank);
    const sideB = side.clone().applyQuaternion(bankQuat);
    const upB   = up.clone().applyQuaternion(bankQuat);

    const halfW = ROAD.width * 0.5;
    const L = p.clone().addScaledVector(sideB, +halfW);
    const R = p.clone().addScaledVector(sideB, -halfW);

    // ===== 도로 =====
    const vi = i*2;
    posAttr.setXYZ(vi,   L.x, L.y, L.z);
    posAttr.setXYZ(vi+1, R.x, R.y, R.z);

    norAttr.setXYZ(vi,   upB.x, upB.y, upB.z);
    norAttr.setXYZ(vi+1, upB.x, upB.y, upB.z);

    const v = (i/(samples.length-1)) * 80.0;
    uvAttr.setXY(vi,   0, v);
    uvAttr.setXY(vi+1, 1, v);

    // ===== 중앙선 =====
    lineAttr.setXYZ(i, p.x, p.y+0.01, p.z);

    // ===== 벽 =====
    const wbi = i*2;

    // 왼쪽 벽
    const Lb = L.clone().addScaledVector(upB, WALL.lift);
    const Lt = Lb.clone().addScaledVector(upB, WALL.height);
    lwPos.setXYZ(wbi,   Lb.x, Lb.y, Lb.z);
    lwPos.setXYZ(wbi+1, Lt.x, Lt.y, Lt.z);
    lwNor.setXYZ(wbi,   sideB.x, sideB.y, sideB.z);
    lwNor.setXYZ(wbi+1, sideB.x, sideB.y, sideB.z);
    lwUv.setXY(wbi,   0, v);
    lwUv.setXY(wbi+1, 1, v);

    // 오른쪽 벽
    const Rb = R.clone().addScaledVector(upB, WALL.lift);
    const Rt = Rb.clone().addScaledVector(upB, WALL.height);
    rwPos.setXYZ(wbi,   Rb.x, Rb.y, Rb.z);
    rwPos.setXYZ(wbi+1, Rt.x, Rt.y, Rt.z);
    rwNor.setXYZ(wbi,   -sideB.x, -sideB.y, -sideB.z);
    rwNor.setXYZ(wbi+1, -sideB.x, -sideB.y, -sideB.z);
    rwUv.setXY(wbi,   0, v);
    rwUv.setXY(wbi+1, 1, v);
  }

  posAttr.needsUpdate = true;
  norAttr.needsUpdate = true;
  uvAttr.needsUpdate  = true;
  roadMesh.geometry.computeBoundingSphere();

  lineAttr.needsUpdate = true;
  centerLine.computeLineDistances();

  lwPos.needsUpdate = true;
  lwNor.needsUpdate = true;
  lwUv.needsUpdate  = true;
  leftWall.geometry.computeBoundingSphere();

  rwPos.needsUpdate = true;
  rwNor.needsUpdate = true;
  rwUv.needsUpdate  = true;
  rightWall.geometry.computeBoundingSphere();
}

const roadGroup = new THREE.Group();
scene.add(roadGroup);

const roadChunks = [];
const chunkSamples = [];

function initRoad(){
  roadGroup.clear();
  roadChunks.length = 0;
  chunkSamples.length = 0;
  resetTrack();

  const first = { pos:new THREE.Vector3(0,ROAD.y,0), heading:0, bank:0, s:0 };
  track.x = 0; track.z = 0; track.heading = 0; track.s = 0;

  let prev = first;
  for (let c=0; c<ROAD.chunks; c++){
    const chunk = makeRoadChunk();
    const samples = [];
    samples.push(prev);
    for (let i=1; i<ROAD.rowsPerChunk; i++){
      const next = advanceTrack(ROAD.step);
      samples.push(next);
      prev = next;
    }
    updateChunkGeometry(chunk, samples);
    roadGroup.add(chunk);
    roadChunks.push(chunk);
    chunkSamples.push(samples);
  }
}
initRoad();

let worldProgress = 0;
let lastRecycleAt = 0;

function recycleRoadIfNeeded(){
  const distSince = worldProgress - lastRecycleAt;
  if (distSince < ROAD.chunkLength) return;

  const jumps = Math.floor(distSince / ROAD.chunkLength);
  if (jumps <= 0) return;

  for (let j=0; j<jumps; j++){
    const chunk = roadChunks.shift();
    roadChunks.push(chunk);

    const prev = chunkSamples[chunkSamples.length-1][ROAD.rowsPerChunk-1];
    const samples = [prev];
    for (let i=1; i<ROAD.rowsPerChunk; i++){
      samples.push(advanceTrack(ROAD.step));
    }

    chunkSamples.shift();
    chunkSamples.push(samples);

    updateChunkGeometry(chunk, samples);
  }

  lastRecycleAt += jumps * ROAD.chunkLength;
}

// ===== 차량 =====
let carIndex = 0;
let carModel = null;
const carRoot = new THREE.Group();
scene.add(carRoot);

const carState = {
  x: 0,
  yaw: 0,
  yawRate: 0,
  speed: 0,
  steerAngle: 0,
  latVel: 0, // ★ 측면 속도: 조향 '질질 끌림' 방지용
};

function loadCar(i){
  carIndex = (i + CAR_PRESETS.length) % CAR_PRESETS.length;
  const preset = CAR_PRESETS[carIndex];

  if (carModel) carRoot.remove(carModel);
  carModel = makeCarModel(preset.kind, preset.color);
  carRoot.add(carModel);

  resetCar(false);
  document.getElementById("hudCar").textContent = preset.name;
  updateStatsPanel();

  // 라이트 토글 상태 반영
  applyHeadlight();
}

function resetCar(rebuildRoad=true){
  carState.x = 0;
  carState.yaw = 0;
  carState.yawRate = 0;
  carState.speed = 0;
  carState.steerAngle = 0;
  carState.latVel = 0;

  worldProgress = 0;
  lastRecycleAt = 0;
  if (rebuildRoad) initRoad();
}

// ===== 입력 =====
const keys = new Set();
window.addEventListener("keydown",(e)=>{
  keys.add(e.code);
  if (e.code === "KeyR") resetCar(true);
});
window.addEventListener("keyup",(e)=> keys.delete(e.code));
function keyDown(code){ return keys.has(code); }

const invertSteerEl = document.getElementById("invertSteer");
function steerInputValue(){
  const left  = keyDown("KeyA") ? 1 : 0;
  const right = keyDown("KeyD") ? 1 : 0;
  let s = (right - left); // 기본: D가 +
  if (invertSteerEl.checked) s = -s;
  return s;
}

// ===== 토글: 라이트/낮밤/안개 =====
let headLightOn = false;
let isNight = true;
let fogOn = true;

function applyHeadlight(){
  const spot = carModel?.userData?.headLight;
  const heads = carModel?.userData?.headMeshes || [];
  if (spot) spot.intensity = headLightOn ? 3.2 : 0;
  // 헤드라이트 메쉬 emissive 느낌 강화/약화
  heads.forEach(m=>{
    if (!m?.material) return;
    m.material.emissive = new THREE.Color(0x2a395a);
    m.material.emissiveIntensity = headLightOn ? 1.3 : 0.35;
    m.material.needsUpdate = true;
  });
  document.getElementById("hudLight").textContent = headLightOn ? "ON" : "OFF";
}

function applyTimeOfDay(){
  const u = sky.material.uniforms;
  if (isNight){
    u.topColor.value.set(0x16224a);
    u.midColor.value.set(0x0a1026);
    u.botColor.value.set(0x05070e);
    moon.intensity = 0.85;
    fill.intensity = 0.25;
    renderer.toneMappingExposure = 1.05;
    if (scene.fog && fogOn) scene.fog.density = 0.0075;
  } else {
    u.topColor.value.set(0x8fd3ff);
    u.midColor.value.set(0x4d8bff);
    u.botColor.value.set(0xd9f2ff);
    moon.intensity = 0.25;
    fill.intensity = 0.35;
    renderer.toneMappingExposure = 1.35;
    if (scene.fog && fogOn) scene.fog.density = 0.0032;
  }
  document.getElementById("hudTime").textContent = isNight ? "NIGHT" : "DAY";
}

function applyFog(){
  if (fogOn){
    scene.fog = new THREE.FogExp2(0x0a0f1e, isNight ? 0.0075 : 0.0032);
  } else {
    scene.fog = null;
  }
  document.getElementById("hudFog").textContent = fogOn ? "ON" : "OFF";
}

window.addEventListener("keydown", (e)=>{
  if (e.code === "KeyL"){
    headLightOn = !headLightOn;
    applyHeadlight();
  }
  if (e.code === "KeyP"){
    isNight = !isNight;
    applyTimeOfDay();
  }
  if (e.code === "KeyM"){
    fogOn = !fogOn;
    applyFog();
  }
});

// ===== 도로 폭 UI =====
const roadWidthInput = document.getElementById("roadWidth");
const roadWidthVal = document.getElementById("roadWidthVal");
roadWidthInput.addEventListener("input", ()=>{
  ROAD.width = parseFloat(roadWidthInput.value);
  roadWidthVal.textContent = String(Math.round(ROAD.width));
  // 즉시 반영: 현재 샘플로 각 청크를 한 번 갱신
  for (let i=0; i<roadChunks.length; i++){
    updateChunkGeometry(roadChunks[i], chunkSamples[i]);
  }
});

// ===== 차량 업데이트(질질 끌림 개선) =====
let safeFlag = "OK";

function updateCar(dt){
  dt = clamp(dt, 0, 0.05);
  const p = CAR_PRESETS[carIndex];

  const throttle = keyDown("KeyW") ? 1 : 0;
  const brake    = keyDown("KeyS") ? 1 : 0;
  const handbrake= keyDown("Space") ? 1 : 0;

  const vmax = mpsFromKmh(p.vmax);
  const accel = p.accel;
  const brakePower = p.brake;

  // 저항
  const drag = 0.020 + Math.abs(carState.speed) * 0.0022;

  // 가속/감속
  let a = 0;
  a += throttle * accel;
  a -= brake * brakePower;
  a -= carState.speed * drag;
  if (handbrake) a -= Math.sign(carState.speed) * 3.5;

  carState.speed += a * dt;
  carState.speed = safe(carState.speed, 0);
  carState.speed = clamp(carState.speed, -vmax*0.35, vmax);

  // 조향
  const steerInput = steerInputValue();
  const grip = p.grip * (handbrake ? 0.55 : 1.0);

  const speedFactor = clamp(1.0 - Math.abs(carState.speed)/(vmax+1e-3), 0.25, 1.0);
  const steerTarget = steerInput * p.steer * speedFactor;

  const steerLambda = 18.0;
  const steerT = 1 - Math.exp(-steerLambda*dt);
  carState.steerAngle = lerp(carState.steerAngle, steerTarget, steerT);
  carState.steerAngle = safe(carState.steerAngle, 0);

  // yaw
  const yawTargetRate = carState.steerAngle * (0.85 + Math.abs(carState.speed)*0.08) * grip;
  const yawLambda = 10.0;
  const yawT = 1 - Math.exp(-yawLambda*dt);
  carState.yawRate = lerp(carState.yawRate, yawTargetRate, yawT);
  carState.yawRate = safe(carState.yawRate, 0);
  carState.yaw += carState.yawRate * dt;
  carState.yaw = safe(carState.yaw, 0);

  // ===== 개선된 측면 물리 (질질 끌림 방지) =====
  // 조향 중 발생하는 측면 "힘" (속도와 조향에 비례)
  const lateralForce = carState.steerAngle * Math.abs(carState.speed) * 0.55 * grip;
  carState.latVel += lateralForce * dt;

  // 조향이 없으면 빠르게 0으로 복귀(직진 안정감)
  const dampingBase = handbrake ? 1.5 : 6.5;
  // 입력이 없을수록 더 강한 감쇠
  const noInputBoost = (Math.abs(steerInput) < 0.05) ? 1.35 : 1.0;
  const lateralDamping = dampingBase * noInputBoost;
  carState.latVel *= Math.exp(-lateralDamping * dt);

  carState.latVel = safe(carState.latVel, 0);

  // 위치 반영
  carState.x += carState.latVel * dt;
  carState.x = safe(carState.x, 0);

  // 도로 밖으로 제한 + 벽 충돌(튕김)
  const maxOff = ROAD.width * 0.62;
  if (carState.x > maxOff){
    carState.x = maxOff;
    carState.latVel = -Math.abs(carState.latVel) * WALL.hitBounce;
    carState.latVel *= WALL.hitDamp;
  } else if (carState.x < -maxOff){
    carState.x = -maxOff;
    carState.latVel = Math.abs(carState.latVel) * WALL.hitBounce;
    carState.latVel *= WALL.hitDamp;
  }

  // 월드 진행
  worldProgress += Math.max(0, carState.speed) * dt;
  worldProgress = safe(worldProgress, 0);

  roadGroup.position.z = -worldProgress;
  roadGroup.position.x = -carState.x * 0.35;

  recycleRoadIfNeeded();

  // 차 적용
  carRoot.position.set(carState.x, 0.0, 0.0);
  carRoot.rotation.y = carState.yaw;

  // 바퀴 회전
  const wheels = carModel?.userData?.wheels || [];
  const wheelSpin = carState.speed * dt * 2.25;
  wheels.forEach((w, idx)=>{
    w.rotation.x += wheelSpin;
    if (idx < 2) w.rotation.y = carState.steerAngle * 0.25;
  });

  safeFlag = "OK";
  if (isBad(carState.speed) || isBad(carState.x) || isBad(worldProgress) || isBad(carState.latVel)) safeFlag = "GUARD";
  if (Math.abs(kmhFromMps(carState.speed)) > p.vmax*1.01) safeFlag = "CLAMP";
}

// ===== 카메라 =====
const camState = { pos: new THREE.Vector3(0,7,14), look: new THREE.Vector3(0,1.2,0) };
function updateCamera(dt){
  dt = clamp(dt, 0, 0.05);
  const spKmh = kmhFromMps(Math.abs(carState.speed));

  const forward = new THREE.Vector3(Math.sin(carState.yaw), 0, Math.cos(carState.yaw));
  const up = new THREE.Vector3(0,1,0);

  const dist = clamp(10 + spKmh*0.03, 10, 26);
  const height = clamp(5.8 + spKmh*0.012, 5.8, 10.5);

  const carPos = new THREE.Vector3(carState.x, 0, 0);

  const targetPos = carPos.clone().addScaledVector(forward, -dist).addScaledVector(up, height);
  const targetLook= carPos.clone().addScaledVector(up, 1.25).addScaledVector(forward, clamp(3+spKmh*0.01, 3, 9));

  expLerpVec(camState.pos, targetPos, 6.0, dt);
  expLerpVec(camState.look, targetLook, 8.0, dt);

  camera.position.copy(vecSafe(camState.pos, new THREE.Vector3(0,7,14)));
  camera.position.y = clamp(camera.position.y, 2.0, 24.0);
  camera.up.set(0,1,0);
  camera.lookAt(vecSafe(camState.look, new THREE.Vector3(0,1.2,0)));
}

// ===== UI =====
const carSelect = document.getElementById("carSelect");
CAR_PRESETS.forEach((c, idx)=>{
  const opt = document.createElement("option");
  opt.value = String(idx);
  opt.textContent = c.name;
  carSelect.appendChild(opt);
});
carSelect.addEventListener("change", ()=> loadCar(parseInt(carSelect.value,10)||0));
document.getElementById("resetBtn").addEventListener("click", ()=> resetCar(true));

let paused = false;
document.getElementById("pauseBtn").addEventListener("click", ()=>{
  paused = !paused;
  document.getElementById("pauseBtn").textContent = paused ? "재개" : "일시정지";
});

function updateStatsPanel(){
  const p = CAR_PRESETS[carIndex];
  document.getElementById("stats").innerHTML = `
    <div><b>성능</b></div>
    <div>최고속: ${p.vmax} km/h</div>
    <div>가속: ${p.accel.toFixed(1)} / 브레이크: ${p.brake.toFixed(1)}</div>
    <div>핸들링: ${p.steer.toFixed(2)} / 그립: ${p.grip.toFixed(2)}</div>
    <div class="muted" style="margin-top:6px;">(L)라이트 (P)낮밤 (M)안개 / 도로폭 조절 / 조향 잔상(질질 끌림) 개선</div>
  `;
}

const hudSpeed = document.getElementById("hudSpeed");
const hudSafe  = document.getElementById("hudSafe");
const hudSteer = document.getElementById("hudSteer");

invertSteerEl.addEventListener("change", ()=>{
  hudSteer.textContent = invertSteerEl.checked ? "A=→ / D=←" : "A=← / D=→";
});

// ===== 리사이즈 =====
const vv = window.visualViewport;
function doResize(){
  const w = Math.floor(vv?.width ?? window.innerWidth);
  const h = Math.floor(vv?.height ?? window.innerHeight);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio||1,2));
  renderer.setSize(w, h, true);
  camera.aspect = w/h;
  camera.updateProjectionMatrix();
}
window.addEventListener("resize", doResize, {passive:true});
vv?.addEventListener("resize", doResize, {passive:true});
doResize();

// ===== 초기 상태 =====
loadCar(0);
carSelect.value = "0";
hudSteer.textContent = "A=← / D=→";
applyFog();
applyTimeOfDay();
applyHeadlight();

// ===== 루프 =====
let last = performance.now();
function tick(now){
  const rawDt = (now-last)/1000; last = now;
  const dt = clamp(rawDt, 0, 0.05);

  if (!paused){
    updateCar(dt);
    updateCamera(dt);
  }

  hudSpeed.textContent = String(Math.round(Math.abs(kmhFromMps(carState.speed))));
  hudSafe.textContent = safeFlag;

  renderer.render(scene, camera);
  requestAnimationFrame(tick);
}
requestAnimationFrame(tick);

</script>
</body>
</html>
