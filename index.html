<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>CarLoad Rebuild v3.0 (Fresh Core)</title>
  <style>
    html, body { margin:0; padding:0; overflow:hidden; background:#0b1020; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    canvas{ display:block; }

    #panel{
      position:fixed; left:12px; top:12px; z-index:10; width: 390px;
      background: rgba(10,12,18,0.62); color:#e9eefc;
      border:1px solid rgba(255,255,255,0.12);
      border-radius:16px; padding:12px;
      backdrop-filter: blur(10px);
      box-shadow: 0 10px 30px rgba(0,0,0,0.40);
    }
    #panel h1{ margin:0 0 8px; font-size:14px; font-weight:900; }
    .row{ display:flex; gap:8px; flex-wrap:wrap; align-items:center; margin:6px 0; }
    select, button, label{
      background: rgba(255,255,255,0.08); color:#e9eefc;
      border:1px solid rgba(255,255,255,0.14);
      border-radius: 12px; padding:8px 10px; font-size:13px;
      outline:none;
    }
    button{ cursor:pointer; }
    button:hover{ background: rgba(255,255,255,0.12); }
    label{ user-select:none; display:flex; align-items:center; gap:8px; }
    input[type="range"]{ width: 140px; }
    input[type="checkbox"]{ transform: translateY(1px); }
    .muted{ font-size:12px; color: rgba(233,238,252,0.78); line-height:1.4; }

    #hud{
      position:fixed; right:12px; top:12px; z-index:10; min-width: 240px;
      background: rgba(10,12,18,0.52); color:#e9eefc;
      border:1px solid rgba(255,255,255,0.12);
      border-radius:16px; padding:10px 12px;
      backdrop-filter: blur(10px);
      box-shadow: 0 10px 30px rgba(0,0,0,0.40);
      font-size:12px; line-height:1.45; text-align:right;
    }
    #toast{
      position:fixed; left:50%; bottom:14px; transform:translateX(-50%);
      z-index:10; padding:8px 14px; border-radius:999px;
      background: rgba(10,12,18,0.38); color: rgba(233,238,252,0.86);
      border:1px solid rgba(255,255,255,0.10);
      backdrop-filter: blur(10px);
      font-size:12px; user-select:none;
    }
  </style>
</head>
<body>
  <div id="panel">
    <h1>CarLoad v3.0 — Road+Rails Infinite + Physics Core</h1>
    <div class="row">
      <select id="carSelect"></select>
      <button id="resetBtn">리셋(R)</button>
      <button id="pauseBtn">일시정지</button>
      <label title="체감이 반대면 켜">
        <input id="invertSteer" type="checkbox" /> 조향 반전
      </label>
    </div>

    <div class="row">
      <label title="도로 폭">
        도로 폭
        <input id="roadWidth" type="range" min="10" max="30" step="1" value="16" />
        <span id="roadWidthVal" class="muted">16</span>
      </label>
      <label title="가드레일 높이">
        레일 높이
        <input id="railHeight" type="range" min="1" max="4" step="0.1" value="1.6" />
        <span id="railHeightVal" class="muted">1.6</span>
      </label>
    </div>

    <div class="muted">
      조작: <b>W</b>가속 / <b>S</b>브레이크 / <b>A,D</b>조향 / <b>Space</b>핸드브레이크 / <b>R</b>리셋<br>
      토글: <b>P</b>낮·밤 / <b>M</b>안개 / <b>L</b>라이트
    </div>
    <div id="stats" class="muted" style="margin-top:8px;"></div>
  </div>

  <div id="hud">
    <div><b id="hudCar">-</b></div>
    <div>속도: <b id="hudSpeed">0</b> km/h</div>
    <div>스티어: <b id="hudSteer">0</b>°</div>
    <div>슬립각: <b id="hudSlip">0</b>°</div>
    <div>YawRate: <b id="hudYaw">0</b>°/s</div>
    <div>상태: <b id="hudSafe">OK</b></div>
    <div>라이트: <b id="hudLight">OFF</b></div>
    <div>시간: <b id="hudTime">DAY</b></div>
    <div>안개: <b id="hudFog">ON</b></div>
  </div>

  <div id="toast">v3.0: "진짜 충돌" 레일 + 자전거 모델 기반 아케이드 물리(슬립/그립/감쇠)</div>

<script type="module">
import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js";

// =========================
// 0) 안전/수학 유틸
// =========================
function isBad(n){ return !Number.isFinite(n) || Number.isNaN(n); }
function safe(n, fallback=0){ return isBad(n) ? fallback : n; }
function clamp(x,a,b){ x = safe(x,a); return Math.max(a, Math.min(b, x)); }
function lerp(a,b,t){ return a + (b-a)*clamp(t,0,1); }
function rad(deg){ return deg * Math.PI / 180; }
function deg(rad){ return rad * 180 / Math.PI; }
function expSmooth(current, target, lambda, dt){
  dt = clamp(dt, 0, 0.05);
  const t = 1 - Math.exp(-lambda * dt);
  return lerp(current, target, t);
}

// =========================
// 1) 렌더/씬
// =========================
const canvas = document.createElement('canvas');
document.body.appendChild(canvas);

const renderer = new THREE.WebGLRenderer({ canvas, antialias:true });
renderer.setPixelRatio(Math.min(window.devicePixelRatio||1, 2));
renderer.setSize(innerWidth, innerHeight, true);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.25;

const scene = new THREE.Scene();

const camera = new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.1, 2400);
camera.position.set(0, 7.2, 14);

// ===== Sky =====
const sky = (()=>{
  const geo = new THREE.SphereGeometry(1200, 32, 16);
  const mat = new THREE.ShaderMaterial({
    side: THREE.BackSide,
    uniforms: {
      topColor:{ value:new THREE.Color(0x8fd3ff) },
      midColor:{ value:new THREE.Color(0x4d8bff) },
      botColor:{ value:new THREE.Color(0xd9f2ff) },
      offset:{ value:0.08 },
      exponent:{ value:0.8 }
    },
    vertexShader:`varying vec3 vWorldPos; void main(){ vec4 wpos=modelMatrix*vec4(position,1.0); vWorldPos=wpos.xyz; gl_Position=projectionMatrix*viewMatrix*wpos; }`,
    fragmentShader:`varying vec3 vWorldPos; uniform vec3 topColor, midColor, botColor; uniform float offset, exponent; void main(){ float h=normalize(vWorldPos).y; float t=pow(max(h+offset,0.0),exponent); vec3 col=mix(botColor, midColor, smoothstep(0.0,0.45,t)); col=mix(col, topColor, smoothstep(0.35,1.0,t)); gl_FragColor=vec4(col,1.0);} `
  });
  const m = new THREE.Mesh(geo, mat);
  m.frustumCulled = false;
  scene.add(m);
  return m;
})();

// ===== Ground =====
const groundMat = new THREE.MeshStandardMaterial({ color:0xd7e7ff, roughness:1.0, metalness:0.0 });
const ground = new THREE.Mesh(new THREE.PlaneGeometry(3400, 3400, 1, 1), groundMat);
ground.rotation.x = -Math.PI/2;
ground.position.y = -0.02;
ground.receiveShadow = true;
scene.add(ground);

// ===== Lights =====
scene.add(new THREE.AmbientLight(0x9fb0ff, 0.45));
scene.add(new THREE.HemisphereLight(0xbfe3ff, 0x101526, 0.55));

const sunMoon = new THREE.DirectionalLight(0xcfe0ff, 0.35);
sunMoon.position.set(120, 180, 40);
sunMoon.castShadow = true;
sunMoon.shadow.mapSize.set(2048, 2048);
sunMoon.shadow.camera.near = 10;
sunMoon.shadow.camera.far  = 620;
sunMoon.shadow.camera.left = -190;
sunMoon.shadow.camera.right= 190;
sunMoon.shadow.camera.top  = 190;
sunMoon.shadow.camera.bottom=-190;
scene.add(sunMoon);

const fill = new THREE.DirectionalLight(0x6ea2ff, 0.35);
fill.position.set(-80, 90, -120);
scene.add(fill);

// ===== Fog (toggle) =====
let fogOn = true;
function setFog(isNight){
  if (!fogOn){ scene.fog = null; return; }
  scene.fog = new THREE.FogExp2(0x0a0f1e, isNight ? 0.0072 : 0.0030);
}

// =========================
// 2) 도로/가드레일/무한반복
//    - "플레이어는 0 근처" / "월드를 뒤로"
//    - 커브는 1D 노이즈로 연속
// =========================
const ROAD = {
  width: 16,
  y: 0,
  step: 2.0,
  chunkLength: 70,
  chunks: 18,
  curvatureLimit: 0.010,
  bankMax: 0.24,
};
ROAD.rows = Math.floor(ROAD.chunkLength / ROAD.step) + 1;

const RAIL = {
  thickness: 0.26,
  height: 1.6,
  lift: 0.02,
  // 충돌 감쇠(튕김 대신 딱 막히는 느낌)
  speedDamp: 0.988,
};

let roadSeed = 1337;
function hash01(n){ const x = Math.sin(n * 127.1 + roadSeed * 0.013) * 43758.5453; return x - Math.floor(x); }
function noise1D(t){ const i=Math.floor(t), f=t-i; const a=hash01(i), b=hash01(i+1); const u=f*f*(3-2*f); return a+(b-a)*u; }

const track = { heading:0, x:0, z:0, s:0 };
function resetTrack(){ track.heading=0; track.x=0; track.z=0; track.s=0; }
function advanceTrack(ds){
  const sNext = track.s + ds;
  const t = sNext * 0.032;
  const n  = (noise1D(t) - 0.5) * 2.0;
  const n2 = (noise1D(t*0.41 + 30.0) - 0.5) * 2.0;
  let curvature = (n*0.64 + n2*0.36) * ROAD.curvatureLimit;
  curvature = clamp(curvature, -ROAD.curvatureLimit, ROAD.curvatureLimit);

  track.heading += curvature * ds;
  track.heading = safe(track.heading, 0);

  track.x += Math.sin(track.heading) * ds;
  track.z += Math.cos(track.heading) * ds;
  track.x = safe(track.x, 0);
  track.z = safe(track.z, 0);
  track.s = sNext;

  const bank = clamp(curvature * 240.0, -ROAD.bankMax, ROAD.bankMax);
  return { pos:new THREE.Vector3(track.x, ROAD.y, track.z), heading:track.heading, bank, s:track.s };
}

function makeRoadChunk(){
  const verts = ROAD.rows * 2;
  const positions = new Float32Array(verts * 3);
  const normals   = new Float32Array(verts * 3);
  const uvs       = new Float32Array(verts * 2);
  const indices = [];
  for (let i=0; i<ROAD.rows-1; i++){
    const a=i*2, b=i*2+1, c=(i+1)*2, d=(i+1)*2+1;
    indices.push(a,b,c, b,d,c);
  }

  const geom = new THREE.BufferGeometry();
  geom.setAttribute('position', new THREE.BufferAttribute(positions,3));
  geom.setAttribute('normal',   new THREE.BufferAttribute(normals,3));
  geom.setAttribute('uv',       new THREE.BufferAttribute(uvs,2));
  geom.setIndex(indices);

  const roadMat = new THREE.MeshStandardMaterial({ color:0x324563, roughness:0.92, metalness:0.03 });
  const mesh = new THREE.Mesh(geom, roadMat);
  mesh.receiveShadow = true;

  const lineGeom = new THREE.BufferGeometry();
  const linePos = new Float32Array(ROAD.rows * 3);
  lineGeom.setAttribute('position', new THREE.BufferAttribute(linePos, 3));
  const lineMat = new THREE.LineDashedMaterial({ color:0x0b1020, dashSize:2.5, gapSize:2.5, transparent:true, opacity:0.55 });
  const centerLine = new THREE.Line(lineGeom, lineMat);

  // 레일(시각용) — 충돌은 수학적으로 처리하므로, 시각은 단순 박스로 충분
  const railMat = new THREE.MeshStandardMaterial({
    color:0x0f1627, roughness:0.55, metalness:0.35,
    emissive:0x172445, emissiveIntensity:0.55
  });
  const railGeo = new THREE.BoxGeometry(RAIL.thickness, RAIL.height, ROAD.chunkLength);
  const leftRail  = new THREE.Mesh(railGeo, railMat);
  const rightRail = new THREE.Mesh(railGeo, railMat);
  leftRail.castShadow = rightRail.castShadow = true;
  leftRail.receiveShadow = rightRail.receiveShadow = true;

  const g = new THREE.Group();
  g.add(mesh);
  g.add(centerLine);
  g.add(leftRail);
  g.add(rightRail);
  g.userData = { mesh, centerLine, leftRail, rightRail };
  return g;
}

function updateChunk(chunk, samples){
  const { mesh, centerLine, leftRail, rightRail } = chunk.userData;
  const pos = mesh.geometry.getAttribute('position');
  const nor = mesh.geometry.getAttribute('normal');
  const uv  = mesh.geometry.getAttribute('uv');
  const lp  = centerLine.geometry.getAttribute('position');

  for (let i=0; i<samples.length; i++){
    const s = samples[i];
    const p = s.pos;
    const yaw = s.heading;
    const bank = s.bank;

    const forward = new THREE.Vector3(Math.sin(yaw), 0, Math.cos(yaw));
    const side = new THREE.Vector3(-forward.z, 0, forward.x);
    const up = new THREE.Vector3(0,1,0);

    const q = new THREE.Quaternion().setFromAxisAngle(forward, bank);
    const sideB = side.clone().applyQuaternion(q);
    const upB = up.clone().applyQuaternion(q);

    const halfW = ROAD.width * 0.5;
    const L = p.clone().addScaledVector(sideB, +halfW);
    const R = p.clone().addScaledVector(sideB, -halfW);

    const vi = i*2;
    pos.setXYZ(vi,   L.x, L.y, L.z);
    pos.setXYZ(vi+1, R.x, R.y, R.z);

    nor.setXYZ(vi,   upB.x, upB.y, upB.z);
    nor.setXYZ(vi+1, upB.x, upB.y, upB.z);

    const v = (i/(samples.length-1)) * 90.0;
    uv.setXY(vi,   0, v);
    uv.setXY(vi+1, 1, v);

    lp.setXYZ(i, p.x, p.y+0.01, p.z);
  }

  pos.needsUpdate = true;
  nor.needsUpdate = true;
  uv.needsUpdate  = true;
  mesh.geometry.computeBoundingSphere();

  lp.needsUpdate = true;
  centerLine.computeLineDistances();

  // 레일 배치: 청크의 시작/끝 샘플 기준(단순)
  const a = samples[0];
  const b = samples[samples.length-1];
  const mid = a.pos.clone().add(b.pos).multiplyScalar(0.5);
  leftRail.position.set(0, RAIL.height*0.5 + RAIL.lift, 0);
  rightRail.position.set(0, RAIL.height*0.5 + RAIL.lift, 0);
  // 청크 그룹은 곧바로 월드 좌표로 고정해두는 대신, roadGroup 전체를 움직이므로
  // 여기서는 단순히 "청크 로컬"에서 좌우 오프셋만 적용.
  const x = ROAD.width * 0.5 + RAIL.thickness*0.5;
  leftRail.position.x = -x;
  rightRail.position.x = +x;
  // z는 청크 자체가 geometry로 이미 만들어진 길이라 0 중심에 둠
}

const roadGroup = new THREE.Group();
scene.add(roadGroup);

let roadChunks = [];
let samplesByChunk = [];

function buildRoad(){
  roadGroup.clear();
  roadChunks = [];
  samplesByChunk = [];
  resetTrack();

  let prev = { pos:new THREE.Vector3(0,ROAD.y,0), heading:0, bank:0, s:0 };
  track.x = 0; track.z = 0; track.heading = 0; track.s = 0;

  for (let c=0; c<ROAD.chunks; c++){
    const chunk = makeRoadChunk();
    const samples = [prev];
    for (let i=1; i<ROAD.rows; i++){
      const next = advanceTrack(ROAD.step);
      samples.push(next);
      prev = next;
    }
    updateChunk(chunk, samples);
    roadGroup.add(chunk);
    roadChunks.push(chunk);
    samplesByChunk.push(samples);
  }
}

let worldProgress = 0;
let lastRecycleAt = 0;

function recycleRoad(){
  const distSince = worldProgress - lastRecycleAt;
  if (distSince < ROAD.chunkLength) return;
  const jumps = Math.floor(distSince / ROAD.chunkLength);
  if (jumps <= 0) return;

  for (let j=0; j<jumps; j++){
    const chunk = roadChunks.shift();
    const oldSamples = samplesByChunk.shift();

    // 마지막 청크 끝에서 이어서 새 샘플 생성
    const prev = samplesByChunk[samplesByChunk.length-1][ROAD.rows-1];
    const samples = [prev];
    for (let i=1; i<ROAD.rows; i++) samples.push(advanceTrack(ROAD.step));

    updateChunk(chunk, samples);

    // 맨 뒤로 붙이기
    roadChunks.push(chunk);
    samplesByChunk.push(samples);
  }

  lastRecycleAt += jumps * ROAD.chunkLength;
}

buildRoad();

// =========================
// 3) 차량(간단 모델) + 라이트
// =========================
function makeCar(color){
  const g = new THREE.Group();
  const body = new THREE.Mesh(new THREE.BoxGeometry(2.1,0.65,4.2), new THREE.MeshStandardMaterial({ color, roughness:0.35, metalness:0.18 }));
  body.position.set(0,0.75,0);
  body.castShadow = true; body.receiveShadow = true;

  const glass = new THREE.Mesh(new THREE.BoxGeometry(1.55,0.45,1.6), new THREE.MeshStandardMaterial({
    color:0x9fb8ff, roughness:0.12, metalness:0.05, transparent:true, opacity:0.33
  }));
  glass.position.set(0,1.03,-0.35);
  glass.castShadow = true; glass.receiveShadow = true;

  const wheelMat = new THREE.MeshStandardMaterial({ color:0x22283a, roughness:0.7, metalness:0.25 });
  const wheelGeo = new THREE.CylinderGeometry(0.42,0.42,0.28, 14);
  function wheel(x,z){
    const w = new THREE.Mesh(wheelGeo, wheelMat);
    w.rotation.z = Math.PI/2;
    w.position.set(x,0.42,z);
    w.castShadow = true; w.receiveShadow = true;
    g.add(w);
    return w;
  }
  const wheels = [wheel(-0.98,1.55), wheel(0.98,1.55), wheel(-0.98,-1.55), wheel(0.98,-1.55)];

  const headMat = new THREE.MeshStandardMaterial({
    color:0xdde6ff, roughness:0.22, metalness:0.0,
    emissive:0x2a395a, emissiveIntensity:0.45
  });
  const hL = new THREE.Mesh(new THREE.BoxGeometry(0.35,0.20,0.10), headMat);
  hL.position.set(-0.75,0.72,2.15);
  const hR = hL.clone(); hR.position.x = 0.75;

  const spot = new THREE.SpotLight(0xddeaff, 0, 38, Math.PI/5, 0.35, 1.8);
  spot.position.set(0,0.85,2.55);
  spot.target.position.set(0,0.45,10);
  spot.castShadow = true;

  const beamMat = new THREE.MeshBasicMaterial({
    color:0xbfd8ff, transparent:true, opacity:0.0,
    blending: THREE.AdditiveBlending, depthWrite:false, side:THREE.DoubleSide
  });
  const beam = new THREE.Mesh(new THREE.ConeGeometry(2.8, 20, 28, 1, true), beamMat);
  beam.rotation.x = Math.PI/2;
  beam.position.set(0,0.75,3.20);
  beam.renderOrder = 10;

  g.add(body, glass, hL, hR);
  g.add(spot, spot.target);
  g.add(beam);

  g.userData = { wheels, headLight: spot, headMeshes:[hL,hR], headBeam: beam };
  return g;
}

const CAR_PRESETS = [
  { name:"Hyundai IONIQ 5 N", color:0x8ad3ff, vmax:150, accel:7.5,  brake:11.5, steerMax:28, mu:1.05 },
  { name:"Mazda Furai",       color:0xff5a7a, vmax:250, accel:10.2, brake:13.0, steerMax:30, mu:1.12 },
  { name:"Huracán EVO Spyder",color:0x9cff68, vmax:330, accel:12.7, brake:14.0, steerMax:26, mu:1.10 },
  { name:"Agera RS",          color:0xffd36e, vmax:400, accel:14.2, brake:14.8, steerMax:24, mu:1.06 },
  { name:"Devel Sixteen",     color:0xcaa7ff, vmax:552, accel:18.0, brake:15.2, steerMax:22, mu:1.02 },
];

function mps(kmh){ return kmh/3.6; }
function kmh(mps){ return mps*3.6; }

let carIndex = 0;
const carRoot = new THREE.Group();
scene.add(carRoot);
let car = null;

// =========================
// 4) 물리(핵심)
//    - 자전거 모델 + 속도 기반 타이어 한계(간단)
//    - '질질' 방지: v(전방)·u(측방) 분리 + 강한 감쇠 + 한계에서 클램프
// =========================
const state = {
  x: 0,          // lateral offset (player space)
  z: 0,          // forward distance (unused because world moves)
  yaw: 0,
  v: 0,          // forward speed (m/s)
  u: 0,          // lateral velocity (m/s)
  r: 0,          // yaw rate (rad/s)
  steer: 0,      // steer angle (rad)
  slip: 0,
};

// 차체/축거리(대충)
const VEH = {
  mass: 1500,
  wheelBase: 2.65,
  lf: 1.25,
  lr: 1.40,
};

// 아케이드 안정화 파라미터
const PHYS = {
  steerResponse: 18.0,       // 스티어 반응
  yawDamp: 10.0,             // yawrate 감쇠
  latDamp: 16.0,             // 측면 속도 감쇠(질질 방지 핵심)
  gripBuild: 10.0,           // 타이어 힘 응답 속도
  lowSpeedAssist: 0.35,      // 저속에서 방향 전환 보조
  handbrakeGripMul: 0.55,
  drag0: 0.020,
  drag1: 0.0024,
};

function loadCar(i){
  carIndex = (i + CAR_PRESETS.length) % CAR_PRESETS.length;
  const p = CAR_PRESETS[carIndex];
  carRoot.clear();
  car = makeCar(p.color);
  carRoot.add(car);

  resetAll(false);
  document.getElementById('hudCar').textContent = p.name;
  document.getElementById('stats').textContent = `vmax ${p.vmax}km/h · accel ${p.accel} · brake ${p.brake} · steerMax ${p.steerMax}° · mu ${p.mu}`;
  applyHeadlight();
}

function resetAll(rebuildRoad=true){
  state.x=0; state.z=0; state.yaw=0; state.v=0; state.u=0; state.r=0; state.steer=0; state.slip=0;
  worldProgress = 0;
  lastRecycleAt = 0;
  if (rebuildRoad) buildRoad();
}

// ===== 입력 =====
const keys = new Set();
addEventListener('keydown', (e)=>{ keys.add(e.code); if (e.code==='KeyR') resetAll(true); });
addEventListener('keyup', (e)=> keys.delete(e.code));
function down(code){ return keys.has(code); }

const invertSteerEl = document.getElementById('invertSteer');
function steerInput(){
  const L = down('KeyA') ? 1 : 0;
  const R = down('KeyD') ? 1 : 0;
  let s = (R - L);
  if (invertSteerEl.checked) s = -s;
  return s;
}

// ===== 낮/밤/안개/라이트 =====
let isNight = false;
let headOn = false;

function applyTime(){
  const u = sky.material.uniforms;
  if (isNight){
    u.topColor.value.set(0x16224a);
    u.midColor.value.set(0x0a1026);
    u.botColor.value.set(0x05070e);
    sunMoon.intensity = 0.85;
    fill.intensity = 0.25;
    renderer.toneMappingExposure = 1.05;
    groundMat.color.set(0x0b1224);
  } else {
    u.topColor.value.set(0x8fd3ff);
    u.midColor.value.set(0x4d8bff);
    u.botColor.value.set(0xd9f2ff);
    sunMoon.intensity = 0.35;
    fill.intensity = 0.35;
    renderer.toneMappingExposure = 1.25;
    groundMat.color.set(0xd7e7ff);
  }
  setFog(isNight);
  document.getElementById('hudTime').textContent = isNight ? 'NIGHT' : 'DAY';
  applyHeadlight();
}

function applyFogUI(){
  setFog(isNight);
  document.getElementById('hudFog').textContent = fogOn ? 'ON' : 'OFF';
}

function applyHeadlight(){
  if (!car) return;
  const spot = car.userData.headLight;
  const beam = car.userData.headBeam;
  const heads = car.userData.headMeshes;
  if (spot) spot.intensity = headOn ? 3.2 : 0;
  const base = headOn ? (isNight ? 0.24 : 0.12) : 0.0;
  if (beam?.material) beam.material.opacity = base;
  heads?.forEach(m=>{ if(m?.material){ m.material.emissiveIntensity = headOn ? 1.15 : 0.40; } });
  document.getElementById('hudLight').textContent = headOn ? 'ON' : 'OFF';
}

addEventListener('keydown', (e)=>{
  if (e.code==='KeyP'){ isNight=!isNight; applyTime(); }
  if (e.code==='KeyM'){ fogOn=!fogOn; applyFogUI(); }
  if (e.code==='KeyL'){ headOn=!headOn; applyHeadlight(); }
});

// =========================
// 5) Physics Step
// =========================
let safeFlag = 'OK';

function step(dt){
  dt = clamp(dt, 0, 0.05);
  const p = CAR_PRESETS[carIndex];

  const throttle = down('KeyW') ? 1 : 0;
  const brake = down('KeyS') ? 1 : 0;
  const hand = down('Space') ? 1 : 0;

  // --- Longitudinal ---
  const vmax = mps(p.vmax);
  const drag = PHYS.drag0 + PHYS.drag1 * Math.abs(state.v);
  let ax = 0;

  // 최고속 접근형 가속(간단)
  const accelScale = clamp(1 - Math.max(0,state.v)/(vmax+1e-3), 0, 1);
  ax += throttle * p.accel * (0.35 + 0.65*accelScale);
  ax -= brake * p.brake;
  ax -= state.v * drag;
  if (hand) ax -= Math.sign(state.v) * 3.2;

  state.v = safe(state.v + ax*dt, 0);
  state.v = clamp(state.v, -vmax*0.20, vmax);

  // --- Steering (input -> steer angle) ---
  const sIn = steerInput();
  const steerMax = rad(p.steerMax);

  // 속도 높을수록 최대 조향 줄이기
  const speedFactor = clamp(1 - Math.abs(state.v)/(vmax+1e-3), 0.22, 1);
  const steerTarget = sIn * steerMax * speedFactor;
  state.steer = expSmooth(state.steer, steerTarget, PHYS.steerResponse, dt);

  // --- Bicycle model-ish lateral dynamics ---
  // 저속에서 모델이 너무 무뎌지는 것 보정(아케이드)
  const vAbs = Math.max(0.5, Math.abs(state.v));

  // slip angle approximation: beta ≈ atan2(u, v)
  const beta = Math.atan2(state.u, vAbs);

  // 타이어 한계: a_lat_max = mu * g
  const mu = p.mu * (hand ? PHYS.handbrakeGripMul : 1.0);
  const g = 9.81;
  const aLatMax = mu * g;

  // 목표 yaw rate: r_target ≈ v/L * tan(steer)
  const rTarget = (state.v / VEH.wheelBase) * Math.tan(state.steer);

  // yaw rate dynamics + 감쇠
  state.r = expSmooth(state.r, rTarget, PHYS.gripBuild, dt);
  state.r *= Math.exp(-PHYS.yawDamp * dt);

  // lateral accel needed: a_lat ≈ v * r
  let aLat = state.v * state.r;

  // 타이어 한계 적용(클램프)
  aLat = clamp(aLat, -aLatMax, +aLatMax);

  // lateral velocity update
  state.u = safe(state.u + aLat * dt, 0);

  // "질질" 방지: 측면 속도 강 감쇠 + 입력 없을수록 더 강하게
  const noSteer = Math.abs(sIn) < 0.02;
  const latD = noSteer ? (PHYS.latDamp * 1.8) : PHYS.latDamp;
  state.u *= Math.exp(-latD * dt);

  // yaw integrate
  state.yaw = safe(state.yaw + state.r * dt, 0);

  // lateral position integrate (player space)
  state.x = safe(state.x + state.u * dt, 0);

  // ===== Guardrail collision (hard) =====
  // car half-width(대충) 고려
  const carHalf = 0.95;
  const limit = (ROAD.width * 0.5) - carHalf;
  if (state.x > limit){
    state.x = limit;
    state.u = 0;
    state.v *= RAIL.speedDamp;
  } else if (state.x < -limit){
    state.x = -limit;
    state.u = 0;
    state.v *= RAIL.speedDamp;
  }

  // ===== World progress (only forward) =====
  worldProgress += Math.max(0, state.v) * dt;
  worldProgress = safe(worldProgress, 0);

  // ===== Apply transforms =====
  roadGroup.position.z = -worldProgress;
  roadGroup.position.x = -state.x * 0.35;

  // car
  carRoot.position.set(state.x, 0, 0);
  carRoot.rotation.y = state.yaw;

  // wheels
  if (car){
    const spin = state.v * dt * 2.35;
    car.userData.wheels.forEach((w, i)=>{
      w.rotation.x += spin;
      if (i<2) w.rotation.y = state.steer * 0.30;
    });
  }

  // slip info
  state.slip = beta;

  recycleRoad();

  safeFlag = 'OK';
  if ([state.x,state.v,state.u,state.yaw,state.r,state.steer,worldProgress].some(isBad)) safeFlag = 'GUARD';
}

// =========================
// 6) 카메라
// =========================
const cam = { px:0, py:7.2, pz:14, lx:0, ly:1.2, lz:0 };
function stepCamera(dt){
  dt = clamp(dt, 0, 0.05);
  const sp = Math.abs(kmh(state.v));

  const forward = new THREE.Vector3(Math.sin(state.yaw), 0, Math.cos(state.yaw));
  const up = new THREE.Vector3(0,1,0);

  const dist = clamp(10 + sp*0.03, 10, 26);
  const height = clamp(5.8 + sp*0.012, 5.8, 10.5);

  const carPos = new THREE.Vector3(state.x, 0, 0);
  const targetPos = carPos.clone().addScaledVector(forward, -dist).addScaledVector(up, height);
  const targetLook= carPos.clone().addScaledVector(up, 1.25).addScaledVector(forward, clamp(3+sp*0.01, 3, 9));

  camera.position.lerp(targetPos, 1 - Math.exp(-6.0*dt));
  const look = new THREE.Vector3(cam.lx, cam.ly, cam.lz).lerp(targetLook, 1 - Math.exp(-8.0*dt));
  cam.lx = look.x; cam.ly = look.y; cam.lz = look.z;

  camera.position.y = clamp(camera.position.y, 2.0, 26.0);
  camera.up.set(0,1,0);
  camera.lookAt(look);
}

// =========================
// 7) UI/옵션 연결
// =========================
const carSelect = document.getElementById('carSelect');
CAR_PRESETS.forEach((c, i)=>{
  const o = document.createElement('option');
  o.value = String(i);
  o.textContent = c.name;
  carSelect.appendChild(o);
});
carSelect.addEventListener('change', ()=> loadCar(parseInt(carSelect.value,10)||0));

document.getElementById('resetBtn').addEventListener('click', ()=> resetAll(true));

let paused = false;
document.getElementById('pauseBtn').addEventListener('click', ()=>{
  paused = !paused;
  document.getElementById('pauseBtn').textContent = paused ? '재개' : '일시정지';
});

// 도로 폭
const roadWidthInput = document.getElementById('roadWidth');
const roadWidthVal = document.getElementById('roadWidthVal');
roadWidthInput.value = String(ROAD.width);
roadWidthVal.textContent = String(ROAD.width);
roadWidthInput.addEventListener('input', ()=>{
  ROAD.width = parseFloat(roadWidthInput.value);
  roadWidthVal.textContent = String(Math.round(ROAD.width));
  buildRoad();
});

// 레일 높이
const railHeightInput = document.getElementById('railHeight');
const railHeightVal = document.getElementById('railHeightVal');
railHeightInput.value = String(RAIL.height);
railHeightVal.textContent = String(RAIL.height);
railHeightInput.addEventListener('input', ()=>{
  RAIL.height = parseFloat(railHeightInput.value);
  railHeightVal.textContent = String(Math.round(RAIL.height*10)/10);
  buildRoad();
});

// =========================
// 8) 리사이즈
// =========================
const vv = window.visualViewport;
function resize(){
  const w = Math.floor(vv?.width ?? innerWidth);
  const h = Math.floor(vv?.height ?? innerHeight);
  renderer.setPixelRatio(Math.min(devicePixelRatio||1,2));
  renderer.setSize(w, h, true);
  camera.aspect = w/h;
  camera.updateProjectionMatrix();
}
addEventListener('resize', resize, {passive:true});
vv?.addEventListener('resize', resize, {passive:true});
resize();

// =========================
// 9) 루프
// =========================
loadCar(0);
carSelect.value = '0';
applyTime();
applyFogUI();
applyHeadlight();

const hudSpeed = document.getElementById('hudSpeed');
const hudSteer = document.getElementById('hudSteer');
const hudSlip  = document.getElementById('hudSlip');
const hudYaw   = document.getElementById('hudYaw');
const hudSafe  = document.getElementById('hudSafe');

let last = performance.now();
function loop(now){
  const dt = clamp((now-last)/1000, 0, 0.05);
  last = now;

  if (!paused){
    step(dt);
    stepCamera(dt);
  }

  hudSpeed.textContent = String(Math.round(Math.abs(kmh(state.v))));
  hudSteer.textContent = String(Math.round(deg(state.steer)));
  hudSlip.textContent  = String(Math.round(deg(state.slip)));
  hudYaw.textContent   = String(Math.round(deg(state.r)));
  hudSafe.textContent  = safeFlag;

  renderer.render(scene, camera);
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

</script>
</body>
</html>
