<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Slow Drive 3D ‚Äî Road Tube + Curves + Car Select</title>
  <style>
    html,body{height:100%;margin:0;overflow:hidden;background:#060812;font-family:system-ui,-apple-system,"Apple SD Gothic Neo","Noto Sans KR",sans-serif}
    canvas{display:block}
    #ui{
      position:fixed;left:14px;top:14px;z-index:10;
      color:#eaf0ff;background:rgba(10,14,26,.55);
      border:1px solid rgba(255,255,255,.10);
      padding:10px 12px;border-radius:14px;backdrop-filter: blur(10px);
      box-shadow:0 12px 32px rgba(0,0,0,.35); user-select:none;
      max-width:min(680px, calc(100vw - 28px));
    }
    .t{font-weight:900;letter-spacing:-.2px}
    .s{color:rgba(234,240,255,.78);font-size:13px;margin-top:6px;line-height:1.35}
    .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap;margin-top:10px}
    label{font-size:12px;color:rgba(234,240,255,.75)}
    select{
      appearance:none;
      padding:8px 10px;border-radius:12px;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(255,255,255,.06);
      color:#eaf0ff;
      outline:none;
    }
    .kbd{font-family:ui-monospace,SFMono-Regular,Menlo,monospace;padding:2px 6px;border-radius:8px;border:1px solid rgba(255,255,255,.12);background:rgba(255,255,255,.06)}
    #hud{
      position:fixed;right:14px;top:14px;z-index:10;
      color:#eaf0ff;background:rgba(10,14,26,.55);
      border:1px solid rgba(255,255,255,.10);
      padding:10px 12px;border-radius:14px;backdrop-filter: blur(10px);
      box-shadow:0 12px 32px rgba(0,0,0,.35); user-select:none;
      text-align:right; min-width:210px;
    }
    #hud .big{font-weight:950;font-size:18px}
    #hud .small{color:rgba(234,240,255,.72);font-size:12px;margin-top:2px}
    #hint{
      position:fixed;left:50%;bottom:18px;transform:translateX(-50%);
      color:#eaf0ff;background:rgba(10,14,26,.62);
      border:1px solid rgba(255,255,255,.10);
      padding:10px 14px;border-radius:999px;backdrop-filter: blur(10px);
      box-shadow:0 12px 32px rgba(0,0,0,.35);
      font-size:13px; user-select:none; pointer-events:none;
      opacity:0; transition:opacity .25s ease, transform .25s ease;
      max-width:min(760px, calc(100vw - 28px));
      text-align:center; line-height:1.35;
    }
    #hint.on{opacity:1; transform:translateX(-50%) translateY(-4px);}
  </style>
</head>
<body>
  <div id="ui">
    <div class="t">Slow Drive 3D (Road + Curves + Car Select)</div>
    <div class="s">
      <span class="kbd">W</span>/<span class="kbd">S</span> Í∞ÄÏÜç/Í∞êÏÜç ¬∑
      <span class="kbd">A</span>/<span class="kbd">D</span> Ï°∞Ìñ• ¬∑
      <span class="kbd">Shift</span> Î∂ÄÏä§Ìä∏ ¬∑
      <span class="kbd">1~5</span> Ï∞® Î≥ÄÍ≤Ω ¬∑
      <span class="kbd">F</span> ÏïàÍ∞ú ¬∑
      <span class="kbd">T</span> ÎÇÆ/Î∞§ ¬∑
      <span class="kbd">R</span> Î¶¨ÏÖã
    </div>

    <div class="row">
      <label for="carSel">Ï∞® ÏÑ†ÌÉù</label>
      <select id="carSel"></select>
      <span id="carSpec" style="font-size:12px;color:rgba(234,240,255,.75)"></span>
    </div>
  </div>

  <div id="hud">
    <div class="big" id="spd">0 km/h</div>
    <div class="small" id="dst">0.0 km</div>
    <div class="small" id="mode">DAY ¬∑ FOG: OFF</div>
    <div class="small" id="carName">CAR: -</div>
  </div>

  <div id="hint"></div>

  <script type="module">
    import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";

    // ===== helpers =====
    const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
    const lerp = (a,b,t)=>a+(b-a)*t;

    function toast(msg){
      const el = document.getElementById('hint');
      el.textContent = msg;
      el.classList.add('on');
      clearTimeout(toast._t);
      toast._t = setTimeout(()=>el.classList.remove('on'), 950);
    }

    // ===== renderer / scene / camera =====
    const renderer = new THREE.WebGLRenderer({ antialias:true });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.setSize(innerWidth, innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    document.body.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(65, innerWidth/innerHeight, 0.1, 4000);

    // ===== environment =====
    let isNight = false;
    let fogOn = false;

    const hemi = new THREE.HemisphereLight(0xbcd7ff, 0x101018, 0.9);
    scene.add(hemi);

    const sun = new THREE.DirectionalLight(0xffffff, 1.2);
    sun.position.set(80, 160, 70);
    scene.add(sun);

    // stars
    const starGeo = new THREE.BufferGeometry();
    const starCount = 1600;
    const starPos = new Float32Array(starCount * 3);
    for(let i=0;i<starCount;i++){
      const r = 800 + Math.random()*1200;
      const th = Math.random()*Math.PI*2;
      const ph = Math.random()*Math.PI*0.45;
      starPos[i*3+0] = Math.cos(th)*Math.sin(ph)*r;
      starPos[i*3+1] = 220 + Math.cos(ph)*r*0.14;
      starPos[i*3+2] = Math.sin(th)*Math.sin(ph)*r;
    }
    starGeo.setAttribute('position', new THREE.BufferAttribute(starPos, 3));
    const stars = new THREE.Points(starGeo, new THREE.PointsMaterial({
      color:0xffffff, size:1.15, sizeAttenuation:true, transparent:true, opacity:0.0
    }));
    scene.add(stars);

    function applyEnv(){
      if(!isNight){
        scene.background = new THREE.Color(0x9fc7ff);
        hemi.intensity = 0.95;
        sun.intensity = 1.15;
        sun.color.setHex(0xffffff);
        stars.material.opacity = 0.0;
      }else{
        scene.background = new THREE.Color(0x050611);
        hemi.intensity = 0.26;
        sun.intensity = 0.35;
        sun.color.setHex(0xaac6ff);
        stars.material.opacity = 0.9;
      }
      scene.fog = fogOn ? new THREE.Fog(isNight ? 0x050611 : 0x9fc7ff, 120, 700) : null;
      document.getElementById('mode').textContent = `${isNight ? "NIGHT" : "DAY"} ¬∑ FOG: ${fogOn ? "ON" : "OFF"}`;
    }
    applyEnv();

    // ===== car profiles =====
    // topSpeed in km/h. accelTier mapped into acceleration curve (low/mid/high behavior).
    const CAR_PROFILES = [
      { id:"ioniq5n", name:"ÌòÑÎåÄ ÏïÑÏù¥Ïò§Îãâ 5 N", topSpeed:150, accelTier:"Ìïò",   accelMul:0.72, color:0x3dd6ff, aero:1.06, grip:1.15 },
      { id:"furai",   name:"Mazda Furai",        topSpeed:250, accelTier:"Ï§ë",   accelMul:0.98, color:0xff5f2e, aero:1.02, grip:1.05 },
      { id:"huracan", name:"Ïö∞ÎùºÏπ∏ ÏóêÎ≥¥ Ïä§ÌååÏù¥Îçî", topSpeed:330, accelTier:"Ï§ëÏÉÅ", accelMul:1.12, color:0x2dd4bf, aero:0.98, grip:1.00 },
      { id:"agera",   name:"ÏïÑÏ†úÎùº RS",         topSpeed:400, accelTier:"ÏÉÅ",   accelMul:1.30, color:0x7c5cff, aero:0.95, grip:0.97 },
      { id:"devel",   name:"Îç∞Î≤® ÏãùÏä§Ìã¥",        topSpeed:552, accelTier:"ÏµúÏÉÅ", accelMul:1.62, color:0xffd166, aero:0.90, grip:0.92 },
    ];

    const sel = document.getElementById('carSel');
    CAR_PROFILES.forEach((c, idx)=>{
      const opt = document.createElement('option');
      opt.value = c.id;
      opt.textContent = `${idx+1}. ${c.name}`;
      sel.appendChild(opt);
    });

    // ===== Car model builder (improved silhouettes) =====
    function buildCar(profile){
      const g = new THREE.Group();

      const bodyMat = new THREE.MeshStandardMaterial({
        color: profile.color,
        roughness: 0.35,
        metalness: 0.16,
        emissive: 0x000000
      });
      const glassMat = new THREE.MeshStandardMaterial({
        color: 0x11162a,
        roughness: 0.18,
        metalness: 0.0
      });
      const darkMat = new THREE.MeshStandardMaterial({ color:0x0f1220, roughness:0.9, metalness:0.0 });

      // wheels
      const wheelGeo = new THREE.CylinderGeometry(0.36, 0.36, 0.28, 14);
      wheelGeo.rotateZ(Math.PI/2);
      function wheel(x,y,z){
        const w = new THREE.Mesh(wheelGeo, darkMat);
        w.position.set(x,y,z);
        g.add(w);
        return w;
      }
      const wheels = [];

      // headlights + underglow
      const headL = new THREE.SpotLight(0xdde9ff, 0.0, 95, Math.PI/9, 0.55, 1.0);
      headL.position.set(-0.55, 0.65, 1.85);
      headL.target.position.set(-0.55, 0.2, 38);
      g.add(headL); g.add(headL.target);

      const headR = headL.clone();
      headR.position.x = 0.55;
      headR.target.position.x = 0.55;
      g.add(headR); g.add(headR.target);

      const under = new THREE.PointLight(profile.color, 0.0, 7.5);
      under.position.set(0, 0.18, 0.1);
      g.add(under);

      // body shapes per car
      if(profile.id === "ioniq5n"){
        const base = new THREE.Mesh(new THREE.BoxGeometry(1.95, 0.60, 3.95), bodyMat);
        base.position.set(0, 0.58, 0);
        g.add(base);

        const roof = new THREE.Mesh(new THREE.BoxGeometry(1.65, 0.55, 2.05), bodyMat);
        roof.position.set(0, 1.03, -0.22);
        g.add(roof);

        const glass = new THREE.Mesh(new THREE.BoxGeometry(1.50, 0.42, 1.70), glassMat);
        glass.position.set(0, 1.06, -0.22);
        g.add(glass);

        const spoiler = new THREE.Mesh(new THREE.BoxGeometry(1.35, 0.12, 0.55), darkMat);
        spoiler.position.set(0, 1.14, -1.72);
        g.add(spoiler);

        wheels.push(wheel(-0.86, 0.30, 1.42), wheel(0.86, 0.30, 1.42), wheel(-0.86, 0.30, -1.42), wheel(0.86, 0.30, -1.42));
      }
      else if(profile.id === "furai"){
        const base = new THREE.Mesh(new THREE.BoxGeometry(1.75, 0.42, 3.65), bodyMat);
        base.position.set(0, 0.48, 0);
        g.add(base);

        const nose = new THREE.Mesh(new THREE.ConeGeometry(0.78, 1.30, 10), bodyMat);
        nose.rotation.x = Math.PI/2;
        nose.position.set(0, 0.48, 2.12);
        g.add(nose);


        const canopy = new THREE.Mesh(new THREE.BoxGeometry(1.22, 0.42, 1.35), glassMat);
        canopy.position.set(0, 0.82, 0.25);
        g.add(canopy);

        const fin = new THREE.Mesh(new THREE.BoxGeometry(0.10, 0.58, 1.25), darkMat);
        fin.position.set(0, 1.08, -0.70);
        g.add(fin);

        wheels.push(wheel(-0.80, 0.26, 1.28), wheel(0.80, 0.26, 1.28), wheel(-0.80, 0.26, -1.28), wheel(0.80, 0.26, -1.28));
      }
      else if(profile.id === "huracan"){
        const base = new THREE.Mesh(new THREE.BoxGeometry(1.88, 0.38, 3.35), bodyMat);
        base.position.set(0, 0.44, 0);
        g.add(base);

        const hood = new THREE.Mesh(new THREE.BoxGeometry(1.78, 0.22, 1.45), bodyMat);
        hood.position.set(0, 0.62, 1.05);
        g.add(hood);

        const cockpit = new THREE.Mesh(new THREE.BoxGeometry(1.38, 0.35, 1.05), glassMat);
        cockpit.position.set(0, 0.80, -0.05);
        g.add(cockpit);

        const rear = new THREE.Mesh(new THREE.BoxGeometry(1.78, 0.22, 1.20), darkMat);
        rear.position.set(0, 0.62, -1.16);
        g.add(rear);

        wheels.push(wheel(-0.87, 0.25, 1.15), wheel(0.87, 0.25, 1.15), wheel(-0.87, 0.25, -1.15), wheel(0.87, 0.25, -1.15));
      }
      else if(profile.id === "agera"){
        const base = new THREE.Mesh(new THREE.BoxGeometry(1.88, 0.38, 3.85), bodyMat);
        base.position.set(0, 0.44, 0);
        g.add(base);

        const nose = new THREE.Mesh(new THREE.ConeGeometry(0.72, 1.18, 12), bodyMat);
        nose.rotation.x = Math.PI/2;
        nose.position.set(0, 0.44, 2.40);
        g.add(nose);

        const canopy = new THREE.Mesh(new THREE.BoxGeometry(1.28, 0.40, 1.30), glassMat);
        canopy.position.set(0, 0.82, 0.26);
        g.add(canopy);

        const wing = new THREE.Mesh(new THREE.BoxGeometry(1.92, 0.10, 0.60), darkMat);
        wing.position.set(0, 0.98, -1.95);
        g.add(wing);

        const wingSt = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.35, 0.12), darkMat);
        const stL = wingSt.clone(); stL.position.set(-0.78, 0.83, -1.78);
        const stR = wingSt.clone(); stR.position.set(0.78, 0.83, -1.78);
        g.add(stL); g.add(stR);

        wheels.push(wheel(-0.87, 0.25, 1.38), wheel(0.87, 0.25, 1.38), wheel(-0.87, 0.25, -1.38), wheel(0.87, 0.25, -1.38));
      }
      else {
        const base = new THREE.Mesh(new THREE.BoxGeometry(2.08, 0.42, 4.45), bodyMat);
        base.position.set(0, 0.48, 0);
        g.add(base);

        const nose = new THREE.Mesh(new THREE.ConeGeometry(0.88, 1.60, 14), bodyMat);
        nose.rotation.x = Math.PI/2;
        nose.position.set(0, 0.48, 2.92);
        g.add(nose);

        const canopy = new THREE.Mesh(new THREE.BoxGeometry(1.38, 0.45, 1.40), glassMat);
        canopy.position.set(0, 0.86, 0.18);
        g.add(canopy);

        const rearBlock = new THREE.Mesh(new THREE.BoxGeometry(2.05, 0.28, 1.35), darkMat);
        rearBlock.position.set(0, 0.62, -2.10);
        g.add(rearBlock);

        wheels.push(wheel(-0.96, 0.26, 1.60), wheel(0.96, 0.26, 1.60), wheel(-0.96, 0.26, -1.60), wheel(0.96, 0.26, -1.60));
      }

      g.userData.wheels = wheels;
      g.userData.headL = headL;
      g.userData.headR = headR;
      g.userData.under = under;

      return g;
    }

    // ===== Road (single smooth ribbon geometry) =====
    // We maintain a rolling set of centerline points ahead, and rebuild a "ribbon" mesh sometimes.
    const ROAD_WIDTH = 10.0;
    const SHOULDER_WIDTH = ROAD_WIDTH * 2.25;

    const ROAD_SAMPLES = 260;      // more = smoother
    const ROAD_SPACING = 7.0;      // meters between samples
    const ROAD_LENGTH = ROAD_SAMPLES * ROAD_SPACING;

    // Materials
    const matRoad = new THREE.MeshStandardMaterial({ color:0x2b2f3a, roughness:0.95, metalness:0.0 });
    const matShoulder = new THREE.MeshStandardMaterial({ color:0x1b1e26, roughness:1.0, metalness:0.0 });
    const matLine = new THREE.MeshStandardMaterial({ color:0xe7ecff, roughness:0.35, metalness:0.0 });

    function buildRibbonGeometry(width){
      // placeholder; will be filled by updateRibbon()
      const geo = new THREE.BufferGeometry();
      const vCount = ROAD_SAMPLES * 2;
      geo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(vCount * 3), 3));
      geo.setAttribute('normal',   new THREE.BufferAttribute(new Float32Array(vCount * 3), 3));
      geo.setAttribute('uv',       new THREE.BufferAttribute(new Float32Array(vCount * 2), 2));
      // indices
      const idx = new Uint32Array((ROAD_SAMPLES - 1) * 6);
      let k = 0;
      for(let i=0;i<ROAD_SAMPLES-1;i++){
        const a = i*2;
        const b = i*2+1;
        const c = (i+1)*2;
        const d = (i+1)*2+1;
        // two triangles: a,c,b and b,c,d
        idx[k++] = a; idx[k++] = c; idx[k++] = b;
        idx[k++] = b; idx[k++] = c; idx[k++] = d;
      }
      geo.setIndex(new THREE.BufferAttribute(idx, 1));
      geo.computeBoundingSphere();
      geo.userData.width = width;
      return geo;
    }

    const roadGeo = buildRibbonGeometry(ROAD_WIDTH);
    const shoulderGeo = buildRibbonGeometry(SHOULDER_WIDTH);

    const roadMesh = new THREE.Mesh(roadGeo, matRoad);
    roadMesh.position.y = 0.02;
    scene.add(roadMesh);

    const shoulderMesh = new THREE.Mesh(shoulderGeo, matShoulder);
    shoulderMesh.position.y = 0.0;
    scene.add(shoulderMesh);

    // lane lines as thin ribbons
    const lineGeoCenter = buildRibbonGeometry(0.22);
    const lineGeoL = buildRibbonGeometry(0.22);
    const lineGeoR = buildRibbonGeometry(0.22);
    const lineCenter = new THREE.Mesh(lineGeoCenter, matLine); lineCenter.position.y = 0.035; scene.add(lineCenter);
    const lineL = new THREE.Mesh(lineGeoL, matLine); lineL.position.y = 0.035; scene.add(lineL);
    const lineR = new THREE.Mesh(lineGeoR, matLine); lineR.position.y = 0.035; scene.add(lineR);

    // Centerline + curvature generator
    const centers = [];
    const headings = []; // yaw
    let yaw = 0;
    let curv = 0;
    let curvTarget = 0;
    let curvBlend = 0;

    function pickCurvTarget(){
      const base = (Math.random()*2-1) * 0.0012; // gentle
      const spice = (Math.random()<0.22) ? (Math.random()*2-1) * 0.0024 : 0;
      curvTarget = clamp(base + spice, -0.0030, 0.0030);
    }
    pickCurvTarget();

    function initRoad(){
      centers.length = 0;
      headings.length = 0;
      yaw = 0;
      curv = 0;
      curvBlend = 0;
      pickCurvTarget();

      let p = new THREE.Vector3(0,0,0);
      for(let i=0;i<ROAD_SAMPLES;i++){
        centers.push(p.clone());
        headings.push(yaw);
        // advance
        const dir = new THREE.Vector3(Math.sin(yaw), 0, -Math.cos(yaw));
        p = p.clone().addScaledVector(dir, ROAD_SPACING);
        // evolve curvature slowly with distance
        curvBlend += 0.004;
        if(curvBlend >= 1){
          curvBlend = 0;
          pickCurvTarget();
        }
        curv = lerp(curv, curvTarget, 0.02);
        yaw = clamp(yaw + curv * ROAD_SPACING, -1.1, 1.1);
      }
    }

    initRoad();

    // Rebuild ribbon vertices from centers
    function updateRibbon(geo, offsetX){
      // offsetX: lateral shift of the whole ribbon (for lane lines)
      const width = geo.userData.width;
      const pos = geo.attributes.position.array;
      const nor = geo.attributes.normal.array;
      const uv  = geo.attributes.uv.array;

      for(let i=0;i<ROAD_SAMPLES;i++){
        const c = centers[i];
        const y = headings[i];
        const right = new THREE.Vector3(Math.cos(y), 0, Math.sin(y)); // perpendicular right
        const half = width * 0.5;

        const leftP  = c.clone().addScaledVector(right, (-half + offsetX));
        const rightP = c.clone().addScaledVector(right, ( half + offsetX));

        // positions
        const base = i*2*3;
        pos[base+0] = leftP.x;  pos[base+1] = leftP.y;  pos[base+2] = leftP.z;
        pos[base+3] = rightP.x; pos[base+4] = rightP.y; pos[base+5] = rightP.z;

        // normals (up)
        nor[base+0] = 0; nor[base+1] = 1; nor[base+2] = 0;
        nor[base+3] = 0; nor[base+4] = 1; nor[base+5] = 0;

        // uv: u across width, v along length
        const v = i / (ROAD_SAMPLES-1);
        const u0 = 0, u1 = 1;
        const buv = i*2*2;
        uv[buv+0] = u0; uv[buv+1] = v * 22; // repeat-ish
        uv[buv+2] = u1; uv[buv+3] = v * 22;
      }

      geo.attributes.position.needsUpdate = true;
      geo.attributes.normal.needsUpdate = true;
      geo.attributes.uv.needsUpdate = true;
      geo.computeBoundingSphere();
    }

    // Dash effect: make center line segments blink by material opacity animation (cheap)
    let dashPhase = 0;

    // ===== Scenery (trees/hills) =====
    const scenery = new THREE.Group();
    scene.add(scenery);

    const treeMatTop = new THREE.MeshStandardMaterial({ color:0x2dd4bf, roughness:0.9 });
    const treeMatTrk = new THREE.MeshStandardMaterial({ color:0x5b3a22, roughness:1.0 });
    const hillMat = new THREE.MeshStandardMaterial({ color:0x2a3252, roughness:1.0 });

    const treeGeoTop = new THREE.ConeGeometry(1.2, 3.5, 7);
    const treeGeoTrk = new THREE.CylinderGeometry(0.25, 0.35, 1.6, 6);
    const hillGeo = new THREE.SphereGeometry(10, 10, 8);

    const deco = [];
    function addTree(){
      const t = new THREE.Group();
      const s = 0.7 + Math.random()*0.9;
      const trunk = new THREE.Mesh(treeGeoTrk, treeMatTrk);
      trunk.position.y = 0.8*s; trunk.scale.setScalar(s);
      t.add(trunk);
      const top = new THREE.Mesh(treeGeoTop, treeMatTop);
      top.position.y = 3.1*s; top.scale.setScalar(s);
      t.add(top);
      scenery.add(t);
      deco.push({ obj:t, kind:"tree", u:Math.random(), side:Math.random()<0.5?-1:1, xOff: (ROAD_WIDTH*0.9 + 6 + Math.random()*26) });
    }
    function addHill(){
      const h = new THREE.Mesh(hillGeo, hillMat);
      const s = 0.9 + Math.random()*1.8;
      h.scale.set(1.7*s, 0.7*s, 1.2*s);
      scenery.add(h);
      deco.push({ obj:h, kind:"hill", u:Math.random(), side:Math.random()<0.5?-1:1, xOff: (ROAD_WIDTH*0.9 + 28 + Math.random()*70), y: 4*s });
    }
    for(let i=0;i<160;i++) addTree();
    for(let i=0;i<40;i++) addHill();

    // place scenery along road by param u in [0,1)
    function placeDeco(){
      for(const d of deco){
        // convert u -> sample index
        const idx = clamp(Math.floor(d.u * (ROAD_SAMPLES-2)) + 1, 1, ROAD_SAMPLES-2);
        const c = centers[idx];
        const y = headings[idx];
        const right = new THREE.Vector3(Math.cos(y), 0, Math.sin(y));
        const side = d.side;
        const x = side * d.xOff;

        const pos = c.clone().addScaledVector(right, x);
        if(d.kind==="tree"){
          d.obj.position.set(pos.x, 0, pos.z);
          d.obj.rotation.y = y;
        }else{
          d.obj.position.set(pos.x, d.y || 6, pos.z);
          d.obj.rotation.y = y*0.25;
        }
      }
    }

    // ===== Player =====
    const keys = new Set();
    addEventListener('keydown', (e)=>{
      keys.add(e.code);

      if(e.code === "KeyF"){ fogOn = !fogOn; applyEnv(); toast(`FOG ${fogOn ? "ON" : "OFF"}`); }
      if(e.code === "KeyT"){ isNight = !isNight; applyEnv(); toast(isNight ? "NIGHT MODE" : "DAY MODE"); }
      if(e.code === "KeyR"){ resetAll(); toast("RESET"); }

      if(e.code.startsWith("Digit")){
        const n = parseInt(e.code.replace("Digit",""),10);
        if(n>=1 && n<=5){
          sel.value = CAR_PROFILES[n-1].id;
          sel.dispatchEvent(new Event('change'));
        }
      }
    });
    addEventListener('keyup', (e)=> keys.delete(e.code));

    const state = {
      speed: 0,       // m/s
      dist: 0,        // meters
      laneX: 0,
      laneV: 0
    };

    let currentCar = CAR_PROFILES[0];
    let car = buildCar(currentCar);
    scene.add(car);

    function applyCarProfile(p){
      currentCar = p;

      scene.remove(car);
      car = buildCar(currentCar);
      scene.add(car);

      document.getElementById('carName').textContent = `CAR: ${p.name}`;
      document.getElementById('carSpec').textContent = `ÏµúÍ≥†ÏÜçÎèÑ ${p.topSpeed} km/h ¬∑ Í∞ÄÏÜç ${p.accelTier}`;
      toast(`${p.name} ÏÑ†ÌÉùÎê®`);

      // soften speed on change
      const maxV = (p.topSpeed/3.6);
      state.speed = Math.min(state.speed, maxV * 0.6);
    }

    sel.value = CAR_PROFILES[0].id;
    CAR_PROFILES.forEach((p,i)=>{ if(p.id===sel.value) applyCarProfile(p); });

    sel.addEventListener('change', ()=>{
      const p = CAR_PROFILES.find(x=>x.id===sel.value) || CAR_PROFILES[0];
      applyCarProfile(p);
    });

    function resetAll(){
      state.speed = 0;
      state.dist = 0;
      state.laneX = 0;
      state.laneV = 0;
      initRoad();
      // randomize scenery
      for(const d of deco){
        d.u = Math.random();
        d.side = Math.random()<0.5?-1:1;
        if(d.kind==="tree") d.xOff = (ROAD_WIDTH*0.9 + 6 + Math.random()*26);
        else { d.xOff = (ROAD_WIDTH*0.9 + 28 + Math.random()*70); d.y = 4*(0.9+Math.random()*1.8); }
      }
    }

    // ===== Acceleration curves (tier -> how much power remains at high speed) =====
    // returns multiplier based on speed ratio r = v/maxV
    function powerCurve(tier, r){
      // r in [0..1+]
      r = clamp(r, 0, 1.2);
      if(tier==="Ìïò"){
        // dies quickly
        return Math.pow(1 - r, 1.55) + 0.08;
      }
      if(tier==="Ï§ë"){
        return Math.pow(1 - r, 1.25) + 0.10;
      }
      if(tier==="Ï§ëÏÉÅ"){
        return Math.pow(1 - r, 1.05) + 0.12;
      }
      if(tier==="ÏÉÅ"){
        return Math.pow(1 - r, 0.88) + 0.14;
      }
      // ÏµúÏÉÅ: stays strong
      return Math.pow(1 - r, 0.62) + 0.18;
    }

    // ===== Road scrolling =====
    // We keep the camera+car near origin by shifting the whole road buffers backward
    // by "consuming" distance and generating new points at the far end.
    let consume = 0; // meters advanced since last sample pop

    function advanceRoadBy(dz){
      consume += dz;

      while(consume >= ROAD_SPACING){
        consume -= ROAD_SPACING;

        // pop the first center and append a new one at the end
        const last = centers[centers.length-1];
        const lastYaw = headings[headings.length-1];

        // evolve curvature slowly
        curvBlend += 0.004;
        if(curvBlend >= 1){ curvBlend = 0; pickCurvTarget(); }
        curv = lerp(curv, curvTarget, 0.02);

        const newYaw = clamp(lastYaw + curv * ROAD_SPACING, -1.1, 1.1);
        const dir = new THREE.Vector3(Math.sin(newYaw), 0, -Math.cos(newYaw));
        const next = last.clone().addScaledVector(dir, ROAD_SPACING);

        centers.shift();
        headings.shift();
        centers.push(next);
        headings.push(newYaw);

        // scenery params move forward (u decreases); recycle when passed
        for(const d of deco){
          d.u -= 1/(ROAD_SAMPLES-1);
          if(d.u < 0.02){
            d.u = 0.95 + Math.random()*0.04;
            d.side = Math.random()<0.5?-1:1;
            if(d.kind==="tree") d.xOff = (ROAD_WIDTH*0.9 + 6 + Math.random()*26);
            else { d.xOff = (ROAD_WIDTH*0.9 + 28 + Math.random()*70); d.y = 4*(0.9+Math.random()*1.8); }
          }
        }
      }

      // apply partial consume as an offset by subtracting along heading[0] direction
      const y0 = headings[0];
      const fwd0 = new THREE.Vector3(Math.sin(y0), 0, -Math.cos(y0));
      const off = fwd0.clone().multiplyScalar(consume);

      // shift all centers backward by off for rendering only
      // (we avoid mutating centers permanently; just create temp view)
      // We'll do this cheaply by writing shifted positions into temporary arrays each rebuild.
      return off;
    }

    // ===== Camera + shake =====
    let shakeT = 0;
    function cameraShake(v, dt){
      // v in m/s. More shake at high speed.
      const intensity = clamp((v*3.6 - 60) / 260, 0, 1);
      shakeT += dt * (2.0 + intensity*6.0);
      const s = intensity * 0.10;
      return {
        x: (Math.sin(shakeT*3.1) + Math.sin(shakeT*1.7))*0.5*s,
        y: (Math.sin(shakeT*2.4))*0.35*s,
        z: (Math.sin(shakeT*2.0))*0.40*s
      };
    }

    // ===== main loop =====
    let last = performance.now();
    let rebuildTimer = 0;

    toast("WÎ°ú Ï∂úÎ∞ú! 1~5Î°ú Ï∞® Î∞îÍæ∏Í∏∞ üöó");

    function tick(){
      const now = performance.now();
      const dt = Math.min(0.033, (now-last)/1000);
      last = now;

      const throttle = (keys.has("KeyW") ? 1 : 0);
      const brakeIn  = (keys.has("KeyS") ? 1 : 0);
      const steerIn  = (keys.has("KeyD") ? 1 : 0) - (keys.has("KeyA") ? 1 : 0);
      const boost    = keys.has("ShiftLeft") || keys.has("ShiftRight");

      // max speed
      const maxV = (currentCar.topSpeed / 3.6) * (boost ? 1.08 : 1.0);

      // accel
      const r = state.speed / Math.max(0.1, maxV);
      const engine = powerCurve(currentCar.accelTier, r);
      const accelBase = 14.0 * currentCar.accelMul * (boost ? 1.20 : 1.0) * engine;

      // braking + aero drag
      const brake = 18.0;
      const aeroDrag = (0.20 + state.speed*0.018) * currentCar.aero;

      if(throttle){
        state.speed += accelBase * dt;
      }else{
        state.speed -= aeroDrag * dt;
      }
      if(brakeIn){
        state.speed -= brake * dt;
      }

      state.speed = clamp(state.speed, 0, maxV);

      // steering (more sensitive at speed, but also more "push out" at speed)
      const laneMax = ROAD_WIDTH/2 - 1.05;
      const steerPower = (7.2 + state.speed*0.22) / currentCar.grip;
      state.laneV += steerIn * steerPower * dt;
      state.laneV *= Math.pow(0.10, dt);
      state.laneX += state.laneV * dt;

      // curve drift: at higher speed, you get pushed outward a bit
      const curvePush = curv * state.speed * state.speed * 0.55 * (1.0/currentCar.grip);
      state.laneX += curvePush * dt;

      // bounds
      const over = Math.max(0, Math.abs(state.laneX) - laneMax);
      if(over>0){
        state.laneX -= Math.sign(state.laneX) * over * 2.7 * dt;
        state.laneV *= 0.6;
      }
      state.laneX = clamp(state.laneX, -laneMax-0.6, laneMax+0.6);

      // distance
      const dz = state.speed * dt;
      state.dist += dz;

      // road advance & get current render offset
      const off = advanceRoadBy(dz);

      // Rebuild road mesh occasionally (not every frame) for performance
      rebuildTimer += dt;
      if(rebuildTimer > 0.050){ // 20fps rebuild feels smooth enough
        rebuildTimer = 0;

        // Make shifted versions of centers on the fly by subtracting off
        // We'll temporarily overwrite a copy array for updateRibbon
        // Cheap trick: subtract off into a temp array of Vector3 references.
        // We'll do it in-place with a backup of off and then re-add? (Nope‚Äîjust compute in loop.)
        // So we create "virtual" shifted centers by writing into a static temp list.
        const tempCenters = updateRibbon._tempCenters || (updateRibbon._tempCenters = Array.from({length:ROAD_SAMPLES}, ()=>new THREE.Vector3()));
        for(let i=0;i<ROAD_SAMPLES;i++){
          tempCenters[i].copy(centers[i]).sub(off);
        }
        // swap centers reference for this rebuild
        const savedCenters = centers;
        updateRibbon._saved = savedCenters;

        // monkey patch: read from tempCenters inside updateRibbon by temporarily swapping
        updateRibbon._centers = tempCenters;

        // wrapped updater reading from updateRibbon._centers
        const oldCenters = centers;
        // we can't reassign const centers; so we modify updateRibbon to read from updateRibbon._centers if present
        // (see below: updateRibbonRead)
        function updateRibbonRead(geo, offsetX){
          const width = geo.userData.width;
          const pos = geo.attributes.position.array;
          const nor = geo.attributes.normal.array;
          const uv  = geo.attributes.uv.array;
          const src = updateRibbon._centers || oldCenters;

          for(let i=0;i<ROAD_SAMPLES;i++){
            const c = src[i];
            const y = headings[i];
            const right = new THREE.Vector3(Math.cos(y), 0, Math.sin(y));
            const half = width * 0.5;

            const leftP  = c.clone().addScaledVector(right, (-half + offsetX));
            const rightP = c.clone().addScaledVector(right, ( half + offsetX));

            const base = i*2*3;
            pos[base+0] = leftP.x;  pos[base+1] = leftP.y;  pos[base+2] = leftP.z;
            pos[base+3] = rightP.x; pos[base+4] = rightP.y; pos[base+5] = rightP.z;

            nor[base+0] = 0; nor[base+1] = 1; nor[base+2] = 0;
            nor[base+3] = 0; nor[base+4] = 1; nor[base+5] = 0;

            const v = i / (ROAD_SAMPLES-1);
            const buv = i*2*2;
            uv[buv+0] = 0; uv[buv+1] = v * 22;
            uv[buv+2] = 1; uv[buv+3] = v * 22;
          }

          geo.attributes.position.needsUpdate = true;
          geo.attributes.normal.needsUpdate = true;
          geo.attributes.uv.needsUpdate = true;
          geo.computeBoundingSphere();
        }

        updateRibbonRead(shoulderGeo, 0);
        updateRibbonRead(roadGeo, 0);

        // lane offsets
        updateRibbonRead(lineGeoCenter, 0);
        updateRibbonRead(lineGeoL, -ROAD_WIDTH/2 + 0.35);
        updateRibbonRead(lineGeoR,  ROAD_WIDTH/2 - 0.35);

        // scenery placement
        placeDeco();

        // dash flicker
        dashPhase += dt * (1.4 + state.speed*0.03);
        const dash = (Math.sin(dashPhase*6.0) > 0) ? 1 : 0;
        // fake dashed centerline by toggling opacity at distance (simple & cheap)
        lineCenter.visible = dash === 1;
      }

      // car placement near origin: use center at index ~6 as "ahead"
      const carIdx = 6;
      const c = centers[carIdx].clone().sub(off);
      const y = headings[carIdx];
      const right = new THREE.Vector3(Math.cos(y), 0, Math.sin(y));
      const fwd = new THREE.Vector3(Math.sin(y), 0, -Math.cos(y));

      const carPos = c.clone()
        .addScaledVector(right, state.laneX)
        .addScaledVector(fwd, 10.0);

      car.position.set(carPos.x, 0, carPos.z);
      car.rotation.y = y + (-steerIn * 0.10);

      // wheel spin
      const wheels = car.userData.wheels || [];
      const spin = state.speed * dt * 2.6;
      for(const w of wheels) w.rotation.x -= spin;

      // lights (night)
      const headI = isNight ? 2.2 : 0.0;
      car.userData.headL.intensity = headI;
      car.userData.headR.intensity = headI;
      car.userData.under.intensity = isNight ? 0.65 : 0.0;

      // camera follow + speed-based lowering + shake
      const kmh = state.speed * 3.6;
      const speed01 = clamp((kmh - 30) / 260, 0, 1);

      const camLow = lerp(6.0, 4.6, speed01);          // lower at speed
      const camBack = lerp(16.0, 13.2, speed01);       // slightly closer
      const camLookAhead = lerp(30.0, 40.0, speed01);  // look further

      const sh = cameraShake(state.speed, dt);

      const camTarget = new THREE.Vector3(
        car.position.x + sh.x,
        camLow + sh.y,
        car.position.z + camBack + sh.z
      );
      camera.position.lerp(camTarget, 1 - Math.pow(0.001, dt));

      const lookAt = new THREE.Vector3(
        car.position.x*0.65,
        1.25,
        car.position.z - camLookAhead
      );
      camera.lookAt(lookAt);

      // HUD
      document.getElementById('spd').textContent = `${Math.round(kmh)} km/h`;
      document.getElementById('dst').textContent = `${(state.dist/1000).toFixed(1)} km`;

      renderer.render(scene, camera);
      requestAnimationFrame(tick);
    }

    // ===== UI toggles =====
    addEventListener('keydown', (e)=>{
      if(e.code === "KeyF"){ /* handled above */ }
      if(e.code === "KeyT"){ /* handled above */ }
    });

    // ===== resize =====
    addEventListener('resize', ()=>{
      renderer.setSize(innerWidth, innerHeight);
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
    });

    // ===== start =====
    // initial meshes build
    updateRibbon(shoulderGeo, 0);
    updateRibbon(roadGeo, 0);
    updateRibbon(lineGeoCenter, 0);
    updateRibbon(lineGeoL, -ROAD_WIDTH/2 + 0.35);
    updateRibbon(lineGeoR,  ROAD_WIDTH/2 - 0.35);
    placeDeco();

    tick();

    // ===== extra key handlers (env + reset) =====
    addEventListener('keydown', (e)=>{
      if(e.repeat) return;
      if(e.code === "KeyF"){ fogOn = !fogOn; applyEnv(); toast(`FOG ${fogOn ? "ON" : "OFF"}`); }
      if(e.code === "KeyT"){ isNight = !isNight; applyEnv(); toast(isNight ? "NIGHT MODE" : "DAY MODE"); }
      if(e.code === "KeyR"){ resetAll(); toast("RESET"); }
    });

  </script>
</body>
</html>
