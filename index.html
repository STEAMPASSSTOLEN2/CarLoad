<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Slow Drive 3D ‚Äî Stable Edition</title>
  <style>
    html,body{height:100%;margin:0;overflow:hidden;background:#060812;font-family:system-ui,-apple-system,"Apple SD Gothic Neo","Noto Sans KR",sans-serif}
    canvas{display:block}
    /* Safari/ÏõπÎ∑∞ÏóêÏÑú Ìù∞ Ïó¨Î∞± Î∞©ÏßÄ: Ï∫îÎ≤ÑÏä§Îäî Î¨¥Ï°∞Í±¥ ÌôîÎ©¥ Ï†ÑÏ≤¥ Í≥†Ï†ï */
    #gl{
      position:fixed; inset:0;
      width:100vw; height:100vh;
      display:block;
    }

    #ui{
      position:fixed;left:14px;top:14px;z-index:10;
      color:#eaf0ff;background:rgba(10,14,26,.55);
      border:1px solid rgba(255,255,255,.10);
      padding:10px 12px;border-radius:14px;backdrop-filter: blur(10px);
      box-shadow:0 12px 32px rgba(0,0,0,.35); user-select:none;
      max-width:min(720px, calc(100vw - 28px));
    }
    .t{font-weight:900;letter-spacing:-.2px}
    .s{color:rgba(234,240,255,.78);font-size:13px;margin-top:6px;line-height:1.35}
    .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap;margin-top:10px}
    label{font-size:12px;color:rgba(234,240,255,.75)}
    select{
      appearance:none;
      padding:8px 10px;border-radius:12px;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(255,255,255,.06);
      color:#eaf0ff;
      outline:none;
    }
    .kbd{font-family:ui-monospace,SFMono-Regular,Menlo,monospace;padding:2px 6px;border-radius:8px;border:1px solid rgba(255,255,255,.12);background:rgba(255,255,255,.06)}

    #hud{
      position:fixed;right:14px;top:14px;z-index:10;
      color:#eaf0ff;background:rgba(10,14,26,.55);
      border:1px solid rgba(255,255,255,.10);
      padding:10px 12px;border-radius:14px;backdrop-filter: blur(10px);
      box-shadow:0 12px 32px rgba(0,0,0,.35); user-select:none;
      text-align:right; min-width:210px;
    }
    #hud .big{font-weight:950;font-size:18px}
    #hud .small{color:rgba(234,240,255,.72);font-size:12px;margin-top:2px}

    #hint{
      position:fixed;left:50%;bottom:18px;transform:translateX(-50%);
      color:#eaf0ff;background:rgba(10,14,26,.62);
      border:1px solid rgba(255,255,255,.10);
      padding:10px 14px;border-radius:999px;backdrop-filter: blur(10px);
      box-shadow:0 12px 32px rgba(0,0,0,.35);
      font-size:13px; user-select:none; pointer-events:none;
      opacity:0; transition:opacity .25s ease, transform .25s ease;
      max-width:min(760px, calc(100vw - 28px));
      text-align:center; line-height:1.35;
    }
    #hint.on{opacity:1; transform:translateX(-50%) translateY(-4px);}
  </style>
</head>
<body>
  <canvas id="gl"></canvas>

  <div id="ui">
    <div class="t">Slow Drive 3D ‚Äî Stable Edition</div>
    <div class="s">
      <span class="kbd">W</span>/<span class="kbd">S</span> Í∞ÄÏÜç/Í∞êÏÜç ¬∑
      <span class="kbd">A</span>/<span class="kbd">D</span> Ï°∞Ìñ• ¬∑
      <span class="kbd">Shift</span> Î∂ÄÏä§Ìä∏ ¬∑
      <span class="kbd">1~5</span> Ï∞® Î≥ÄÍ≤Ω ¬∑
      <span class="kbd">F</span> ÏïàÍ∞ú ¬∑
      <span class="kbd">T</span> ÎÇÆ/Î∞§ ¬∑
      <span class="kbd">R</span> Î¶¨ÏÖã
    </div>
    <div class="row">
      <label for="carSel">Ï∞® ÏÑ†ÌÉù</label>
      <select id="carSel"></select>
      <span id="carSpec" style="font-size:12px;color:rgba(234,240,255,.75)"></span>
    </div>
  </div>

  <div id="hud">
    <div class="big" id="spd">0 km/h</div>
    <div class="small" id="dst">0.0 km</div>
    <div class="small" id="mode">DAY ¬∑ FOG: OFF</div>
    <div class="small" id="carName">CAR: -</div>
  </div>

  <div id="hint"></div>

  <script type="module">
    import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";

    // ===== util =====
    const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
    const lerp  = (a,b,t)=>a+(b-a)*t;

    function toast(msg){
      const el = document.getElementById('hint');
      el.textContent = msg;
      el.classList.add('on');
      clearTimeout(toast._t);
      toast._t = setTimeout(()=>el.classList.remove('on'), 950);
    }

    // ===== renderer/scene/camera =====
    const canvas = document.getElementById('gl');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias:true, alpha:false, powerPreference:"high-performance" });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.setSize(innerWidth, innerHeight, false);
    renderer.outputColorSpace = THREE.SRGBColorSpace;

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(65, innerWidth/innerHeight, 0.1, 5000);

    // ===== env (day/night/fog/stars) =====
    let isNight = false;
    let fogOn = false;

    const hemi = new THREE.HemisphereLight(0xbcd7ff, 0x101018, 0.9);
    scene.add(hemi);

    const sun = new THREE.DirectionalLight(0xffffff, 1.2);
    sun.position.set(80, 160, 70);
    scene.add(sun);

    const starGeo = new THREE.BufferGeometry();
    const starCount = 1400;
    const starPos = new Float32Array(starCount*3);
    for(let i=0;i<starCount;i++){
      const r = 900 + Math.random()*1200;
      const th = Math.random()*Math.PI*2;
      const ph = Math.random()*Math.PI*0.45;
      starPos[i*3+0] = Math.cos(th)*Math.sin(ph)*r;
      starPos[i*3+1] = 220 + Math.cos(ph)*r*0.14;
      starPos[i*3+2] = Math.sin(th)*Math.sin(ph)*r;
    }
    starGeo.setAttribute('position', new THREE.BufferAttribute(starPos, 3));
    const stars = new THREE.Points(starGeo, new THREE.PointsMaterial({
      color:0xffffff, size:1.15, sizeAttenuation:true, transparent:true, opacity:0.0
    }));
    scene.add(stars);

    function applyEnv(){
      if(!isNight){
        scene.background = new THREE.Color(0x9fc7ff);
        hemi.intensity = 0.95;
        sun.intensity  = 1.15;
        sun.color.setHex(0xffffff);
        stars.material.opacity = 0.0;
      }else{
        scene.background = new THREE.Color(0x050611);
        hemi.intensity = 0.26;
        sun.intensity  = 0.35;
        sun.color.setHex(0xaac6ff);
        stars.material.opacity = 0.9;
      }
      scene.fog = fogOn ? new THREE.Fog(isNight ? 0x050611 : 0x9fc7ff, 140, 820) : null;
      document.getElementById('mode').textContent = `${isNight ? "NIGHT" : "DAY"} ¬∑ FOG: ${fogOn ? "ON" : "OFF"}`;
    }
    applyEnv();

    // ===== cars =====
    const CAR_PROFILES = [
      { id:"ioniq5n", name:"ÌòÑÎåÄ ÏïÑÏù¥Ïò§Îãâ 5 N", topSpeed:150, accelTier:"Ìïò",   accelMul:0.72, color:0x3dd6ff, aero:1.06, grip:1.15 },
      { id:"furai",   name:"Mazda Furai",        topSpeed:250, accelTier:"Ï§ë",   accelMul:0.98, color:0xff5f2e, aero:1.02, grip:1.05 },
      { id:"huracan", name:"Ïö∞ÎùºÏπ∏ ÏóêÎ≥¥ Ïä§ÌååÏù¥Îçî", topSpeed:330, accelTier:"Ï§ëÏÉÅ", accelMul:1.12, color:0x2dd4bf, aero:0.98, grip:1.00 },
      { id:"agera",   name:"ÏïÑÏ†úÎùº RS",         topSpeed:400, accelTier:"ÏÉÅ",   accelMul:1.30, color:0x7c5cff, aero:0.95, grip:0.97 },
      { id:"devel",   name:"Îç∞Î≤® ÏãùÏä§Ìã¥",        topSpeed:552, accelTier:"ÏµúÏÉÅ", accelMul:1.62, color:0xffd166, aero:0.90, grip:0.92 },
    ];

    const sel = document.getElementById('carSel');
    CAR_PROFILES.forEach((c, idx)=>{
      const opt = document.createElement('option');
      opt.value = c.id;
      opt.textContent = `${idx+1}. ${c.name}`;
      sel.appendChild(opt);
    });

    function buildCar(profile){
      const g = new THREE.Group();

      const bodyMat = new THREE.MeshStandardMaterial({ color:profile.color, roughness:0.35, metalness:0.16 });
      const glassMat= new THREE.MeshStandardMaterial({ color:0x11162a, roughness:0.18, metalness:0.0 });
      const darkMat = new THREE.MeshStandardMaterial({ color:0x0f1220, roughness:0.9, metalness:0.0 });

      // wheels (share geo)
      const wheelGeo = new THREE.CylinderGeometry(0.36,0.36,0.28,14);
      wheelGeo.rotateZ(Math.PI/2);
      const wheels = [];
      const addWheel = (x,y,z)=>{
        const w = new THREE.Mesh(wheelGeo, darkMat);
        w.position.set(x,y,z);
        g.add(w);
        wheels.push(w);
      };

      // lights
      const headL = new THREE.SpotLight(0xdde9ff, 0.0, 95, Math.PI/9, 0.55, 1.0);
      headL.position.set(-0.55, 0.65, 1.85);
      headL.target.position.set(-0.55, 0.2, 38);
      g.add(headL); g.add(headL.target);

      const headR = headL.clone();
      headR.position.x = 0.55;
      headR.target.position.x = 0.55;
      g.add(headR); g.add(headR.target);

      const under = new THREE.PointLight(profile.color, 0.0, 7.5);
      under.position.set(0, 0.18, 0.1);
      g.add(under);

      // body shapes
      if(profile.id==="ioniq5n"){
        const base = new THREE.Mesh(new THREE.BoxGeometry(1.95,0.60,3.95), bodyMat); base.position.set(0,0.58,0); g.add(base);
        const roof = new THREE.Mesh(new THREE.BoxGeometry(1.65,0.55,2.05), bodyMat); roof.position.set(0,1.03,-0.22); g.add(roof);
        const glass= new THREE.Mesh(new THREE.BoxGeometry(1.50,0.42,1.70), glassMat); glass.position.set(0,1.06,-0.22); g.add(glass);
        const spoiler=new THREE.Mesh(new THREE.BoxGeometry(1.35,0.12,0.55), darkMat); spoiler.position.set(0,1.14,-1.72); g.add(spoiler);
        addWheel(-0.86,0.30, 1.42); addWheel(0.86,0.30, 1.42); addWheel(-0.86,0.30,-1.42); addWheel(0.86,0.30,-1.42);
      }else if(profile.id==="furai"){
        const base = new THREE.Mesh(new THREE.BoxGeometry(1.75,0.42,3.65), bodyMat); base.position.set(0,0.48,0); g.add(base);
        const nose = new THREE.Mesh(new THREE.ConeGeometry(0.78,1.30,10), bodyMat); nose.rotation.x=Math.PI/2; nose.position.set(0,0.48,2.12); g.add(nose);
        const canopy=new THREE.Mesh(new THREE.BoxGeometry(1.22,0.42,1.35), glassMat); canopy.position.set(0,0.82,0.25); g.add(canopy);
        const fin  = new THREE.Mesh(new THREE.BoxGeometry(0.10,0.58,1.25), darkMat); fin.position.set(0,1.08,-0.70); g.add(fin);
        addWheel(-0.80,0.26, 1.28); addWheel(0.80,0.26, 1.28); addWheel(-0.80,0.26,-1.28); addWheel(0.80,0.26,-1.28);
      }else if(profile.id==="huracan"){
        const base = new THREE.Mesh(new THREE.BoxGeometry(1.88,0.38,3.35), bodyMat); base.position.set(0,0.44,0); g.add(base);
        const hood = new THREE.Mesh(new THREE.BoxGeometry(1.78,0.22,1.45), bodyMat); hood.position.set(0,0.62,1.05); g.add(hood);
        const cockpit=new THREE.Mesh(new THREE.BoxGeometry(1.38,0.35,1.05), glassMat); cockpit.position.set(0,0.80,-0.05); g.add(cockpit);
        const rear = new THREE.Mesh(new THREE.BoxGeometry(1.78,0.22,1.20), darkMat); rear.position.set(0,0.62,-1.16); g.add(rear);
        addWheel(-0.87,0.25, 1.15); addWheel(0.87,0.25, 1.15); addWheel(-0.87,0.25,-1.15); addWheel(0.87,0.25,-1.15);
      }else if(profile.id==="agera"){
        const base = new THREE.Mesh(new THREE.BoxGeometry(1.88,0.38,3.85), bodyMat); base.position.set(0,0.44,0); g.add(base);
        const nose = new THREE.Mesh(new THREE.ConeGeometry(0.72,1.18,12), bodyMat); nose.rotation.x=Math.PI/2; nose.position.set(0,0.44,2.40); g.add(nose);
        const canopy=new THREE.Mesh(new THREE.BoxGeometry(1.28,0.40,1.30), glassMat); canopy.position.set(0,0.82,0.26); g.add(canopy);
        const wing = new THREE.Mesh(new THREE.BoxGeometry(1.92,0.10,0.60), darkMat); wing.position.set(0,0.98,-1.95); g.add(wing);
        const stGeo = new THREE.BoxGeometry(0.12,0.35,0.12);
        const stL = new THREE.Mesh(stGeo, darkMat); stL.position.set(-0.78,0.83,-1.78); g.add(stL);
        const stR = new THREE.Mesh(stGeo, darkMat); stR.position.set( 0.78,0.83,-1.78); g.add(stR);
        addWheel(-0.87,0.25, 1.38); addWheel(0.87,0.25, 1.38); addWheel(-0.87,0.25,-1.38); addWheel(0.87,0.25,-1.38);
      }else{ // devel
        const base = new THREE.Mesh(new THREE.BoxGeometry(2.08,0.42,4.45), bodyMat); base.position.set(0,0.48,0); g.add(base);
        const nose = new THREE.Mesh(new THREE.ConeGeometry(0.88,1.60,14), bodyMat); nose.rotation.x=Math.PI/2; nose.position.set(0,0.48,2.92); g.add(nose);
        const canopy=new THREE.Mesh(new THREE.BoxGeometry(1.38,0.45,1.40), glassMat); canopy.position.set(0,0.86,0.18); g.add(canopy);
        const rear = new THREE.Mesh(new THREE.BoxGeometry(2.05,0.28,1.35), darkMat); rear.position.set(0,0.62,-2.10); g.add(rear);
        addWheel(-0.96,0.26, 1.60); addWheel(0.96,0.26, 1.60); addWheel(-0.96,0.26,-1.60); addWheel(0.96,0.26,-1.60);
      }

      g.userData.wheels = wheels;
      g.userData.headL = headL;
      g.userData.headR = headR;
      g.userData.under = under;
      return g;
    }

    let currentCar = CAR_PROFILES[0];
    let car = buildCar(currentCar);
    scene.add(car);

    function applyCarProfile(p){
      currentCar = p;
      scene.remove(car);
      car = buildCar(currentCar);
      scene.add(car);

      document.getElementById('carName').textContent = `CAR: ${p.name}`;
      document.getElementById('carSpec').textContent = `ÏµúÍ≥†ÏÜçÎèÑ ${p.topSpeed} km/h ¬∑ Í∞ÄÏÜç ${p.accelTier}`;
      toast(`${p.name} ÏÑ†ÌÉùÎê®`);
    }

    sel.value = currentCar.id;
    applyCarProfile(currentCar);

    sel.addEventListener('change', ()=>{
      const p = CAR_PROFILES.find(x=>x.id===sel.value) || CAR_PROFILES[0];
      applyCarProfile(p);
      state.speed = Math.min(state.speed, (p.topSpeed/3.6) * 0.65);
    });

    // ===== road ribbon (stable typed arrays) =====
    const ROAD_WIDTH = 10.0;
    const SHOULDER_W = ROAD_WIDTH * 2.25;

    const N = 240;          // samples
    const SPACING = 7.0;    // meters
    const LENGTH = N * SPACING;

    // centerline buffers
    const cx = new Float32Array(N);
    const cz = new Float32Array(N);
    const yawArr = new Float32Array(N);

    let yaw = 0;
    let curv = 0;
    let curvTarget = 0;
    let curvBlend = 0;

    function pickCurvTarget(){
      const base = (Math.random()*2-1) * 0.0012;
      const spice = (Math.random()<0.22) ? (Math.random()*2-1) * 0.0024 : 0;
      curvTarget = clamp(base + spice, -0.0030, 0.0030);
    }
    pickCurvTarget();

    function initRoad(){
      yaw = 0; curv = 0; curvBlend = 0; pickCurvTarget();
      let x=0, z=0;
      for(let i=0;i<N;i++){
        cx[i]=x; cz[i]=z; yawArr[i]=yaw;
        // advance
        const sx = Math.sin(yaw), czm = -Math.cos(yaw);
        x += sx*SPACING;
        z += czm*SPACING;
        curvBlend += 0.004;
        if(curvBlend>=1){ curvBlend=0; pickCurvTarget(); }
        curv = lerp(curv, curvTarget, 0.02);
        yaw = clamp(yaw + curv*SPACING, -1.1, 1.1);
      }
    }
    initRoad();

    function makeRibbonGeo(width){
      const geo = new THREE.BufferGeometry();
      geo.userData.width = width;

      const vCount = N*2;
      geo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(vCount*3), 3));
      geo.setAttribute('normal',   new THREE.BufferAttribute(new Float32Array(vCount*3), 3));
      geo.setAttribute('uv',       new THREE.BufferAttribute(new Float32Array(vCount*2), 2));

      const idx = new Uint32Array((N-1)*6);
      let k=0;
      for(let i=0;i<N-1;i++){
        const a=i*2, b=i*2+1, c=(i+1)*2, d=(i+1)*2+1;
        idx[k++]=a; idx[k++]=c; idx[k++]=b;
        idx[k++]=b; idx[k++]=c; idx[k++]=d;
      }
      geo.setIndex(new THREE.BufferAttribute(idx,1));
      return geo;
    }

    // dashed texture (for center line)
    function makeDashTexture(){
      const c = document.createElement('canvas');
      c.width = 64; c.height = 16;
      const g = c.getContext('2d');
      g.clearRect(0,0,c.width,c.height);
      g.fillStyle = "rgba(255,255,255,1)";
      g.fillRect(0, 6, 28, 4);     // dash
      // gap then another dash
      g.fillRect(38, 6, 18, 4);
      const tex = new THREE.CanvasTexture(c);
      tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
      tex.repeat.set(1, 40);       // vÎ∞©Ìñ• Î∞òÎ≥µ
      tex.anisotropy = 2;
      return tex;
    }

    const matRoad = new THREE.MeshStandardMaterial({ color:0x2b2f3a, roughness:0.95, metalness:0.0 });
    const matShoulder = new THREE.MeshStandardMaterial({ color:0x1b1e26, roughness:1.0, metalness:0.0 });
    const matLineSolid = new THREE.MeshStandardMaterial({ color:0xe7ecff, roughness:0.35, metalness:0.0 });

    const dashTex = makeDashTexture();
    const matDash = new THREE.MeshBasicMaterial({ color:0xffffff, map:dashTex, transparent:true, opacity:0.95 });

    const geoShoulder = makeRibbonGeo(SHOULDER_W);
    const geoRoad = makeRibbonGeo(ROAD_WIDTH);
    const geoLineC = makeRibbonGeo(0.22);
    const geoLineL = makeRibbonGeo(0.22);
    const geoLineR = makeRibbonGeo(0.22);

    const shoulder = new THREE.Mesh(geoShoulder, matShoulder); shoulder.position.y=0.0; scene.add(shoulder);
    const road     = new THREE.Mesh(geoRoad, matRoad);        road.position.y=0.02; scene.add(road);
    const lineC    = new THREE.Mesh(geoLineC, matDash);       lineC.position.y=0.035; scene.add(lineC);
    const lineL    = new THREE.Mesh(geoLineL, matLineSolid);  lineL.position.y=0.035; scene.add(lineL);
    const lineR    = new THREE.Mesh(geoLineR, matLineSolid);  lineR.position.y=0.035; scene.add(lineR);

    // update ribbon vertices with an offset (consume)
    function writeRibbon(geo, offsetX, offX, offZ){
      const width = geo.userData.width;
      const pos = geo.attributes.position.array;
      const nor = geo.attributes.normal.array;
      const uv  = geo.attributes.uv.array;

      const half = width*0.5;
      for(let i=0;i<N;i++){
        const y = yawArr[i];
        const rx = Math.cos(y), rz = Math.sin(y); // right vector
        const x = cx[i]-offX;
        const z = cz[i]-offZ;

        const lx = x + rx*(-half + offsetX);
        const lz = z + rz*(-half + offsetX);
        const rxp= x + rx*( half + offsetX);
        const rzp= z + rz*( half + offsetX);

        const p = i*2*3;
        pos[p+0]=lx;  pos[p+1]=0; pos[p+2]=lz;
        pos[p+3]=rxp; pos[p+4]=0; pos[p+5]=rzp;

        nor[p+0]=0; nor[p+1]=1; nor[p+2]=0;
        nor[p+3]=0; nor[p+4]=1; nor[p+5]=0;

        const v = i/(N-1);
        const t = i*2*2;
        uv[t+0]=0; uv[t+1]=v*22;
        uv[t+2]=1; uv[t+3]=v*22;
      }

      geo.attributes.position.needsUpdate = true;
      geo.attributes.normal.needsUpdate = true;
      geo.attributes.uv.needsUpdate = true;
      geo.computeBoundingSphere();
    }

    // ===== scenery (simple, stable; Ï†ÅÎãπÌûà Í∞ÄÎ≥çÍ≤å) =====
    const scenery = new THREE.Group(); scene.add(scenery);

    const treeMatTop = new THREE.MeshStandardMaterial({ color:0x2dd4bf, roughness:0.9 });
    const treeMatTrk = new THREE.MeshStandardMaterial({ color:0x5b3a22, roughness:1.0 });
    const hillMat    = new THREE.MeshStandardMaterial({ color:0x2a3252, roughness:1.0 });

    const treeGeoTop = new THREE.ConeGeometry(1.2, 3.5, 7);
    const treeGeoTrk = new THREE.CylinderGeometry(0.25, 0.35, 1.6, 6);
    const hillGeo    = new THREE.SphereGeometry(10, 10, 8);

    const deco = [];
    function addTree(){
      const t = new THREE.Group();
      const s = 0.7 + Math.random()*0.9;
      const trunk = new THREE.Mesh(treeGeoTrk, treeMatTrk);
      trunk.position.y = 0.8*s; trunk.scale.setScalar(s); t.add(trunk);
      const top = new THREE.Mesh(treeGeoTop, treeMatTop);
      top.position.y = 3.1*s; top.scale.setScalar(s); t.add(top);
      scenery.add(t);
      deco.push({ obj:t, kind:"tree", u:Math.random(), side:Math.random()<0.5?-1:1, xOff:(ROAD_WIDTH*0.9 + 6 + Math.random()*26) });
    }
    function addHill(){
      const h = new THREE.Mesh(hillGeo, hillMat);
      const s = 0.9 + Math.random()*1.8;
      h.scale.set(1.7*s, 0.7*s, 1.2*s);
      scenery.add(h);
      deco.push({ obj:h, kind:"hill", u:Math.random(), side:Math.random()<0.5?-1:1, xOff:(ROAD_WIDTH*0.9 + 28 + Math.random()*70), y:4*s });
    }
    for(let i=0;i<150;i++) addTree();
    for(let i=0;i<38;i++) addHill();

    function placeDeco(offX, offZ){
      for(const d of deco){
        const idx = clamp((d.u*(N-2))|0, 1, N-2);
        const y = yawArr[idx];
        const rx = Math.cos(y), rz = Math.sin(y);
        const x = cx[idx]-offX;
        const z = cz[idx]-offZ;

        const side = d.side;
        const ox = side*d.xOff;
        const px = x + rx*ox;
        const pz = z + rz*ox;

        d.obj.position.set(px, d.kind==="hill" ? (d.y||6) : 0, pz);
        d.obj.rotation.y = (d.kind==="hill") ? y*0.25 : y;
      }
    }

    // ===== physics =====
    const keys = new Set();
    const state = { speed:0, dist:0, laneX:0, laneV:0 };

    function powerCurve(tier, r){
      r = clamp(r, 0, 1.2);
      if(tier==="Ìïò")   return Math.pow(1-r, 1.55) + 0.08;
      if(tier==="Ï§ë")   return Math.pow(1-r, 1.25) + 0.10;
      if(tier==="Ï§ëÏÉÅ") return Math.pow(1-r, 1.05) + 0.12;
      if(tier==="ÏÉÅ")   return Math.pow(1-r, 0.88) + 0.14;
      return Math.pow(1-r, 0.62) + 0.18; // ÏµúÏÉÅ
    }

    // ===== road advance (stable) =====
    let consume = 0; // meters into first segment

    function advanceRoad(dz){
      consume += dz;

      while(consume >= SPACING){
        consume -= SPACING;

        // shift buffers left by 1 (typed array copyWithin: Îπ†Î•¥Í≥† ÏïàÏ†ï)
        cx.copyWithin(0, 1);
        cz.copyWithin(0, 1);
        yawArr.copyWithin(0, 1);

        // generate new sample at end
        const lastX = cx[N-2];
        const lastZ = cz[N-2];
        const lastYaw = yawArr[N-2];

        curvBlend += 0.004;
        if(curvBlend >= 1){ curvBlend = 0; pickCurvTarget(); }
        curv = lerp(curv, curvTarget, 0.02);

        const newYaw = clamp(lastYaw + curv*SPACING, -1.1, 1.1);
        const sx = Math.sin(newYaw), czm = -Math.cos(newYaw);

        cx[N-1] = lastX + sx*SPACING;
        cz[N-1] = lastZ + czm*SPACING;
        yawArr[N-1] = newYaw;

        // scenery param Ïù¥Îèô(ÏïûÏóêÏÑú ÏßÄÎÇòÍ∞ÄÎ©¥ Îí§Î°ú Ïû¨ÏÉùÏÑ±)
        const du = 1/(N-1);
        for(const d of deco){
          d.u -= du;
          if(d.u < 0.02){
            d.u = 0.95 + Math.random()*0.04;
            d.side = Math.random()<0.5?-1:1;
            if(d.kind==="tree") d.xOff = (ROAD_WIDTH*0.9 + 6 + Math.random()*26);
            else { d.xOff = (ROAD_WIDTH*0.9 + 28 + Math.random()*70); d.y = 4*(0.9+Math.random()*1.8); }
          }
        }
      }

      // partial consume offset along heading[0]
      const y0 = yawArr[0];
      const offX = Math.sin(y0) * consume;
      const offZ = -Math.cos(y0) * consume;
      return { offX, offZ };
    }

    // ===== camera (lower + shake) =====
    let shakeT = 0;
    function getShake(v, dt){
      const kmh = v*3.6;
      const intensity = clamp((kmh-60)/260, 0, 1);
      shakeT += dt*(2.0 + intensity*6.0);
      const s = intensity*0.10;
      return {
        x: (Math.sin(shakeT*3.1) + Math.sin(shakeT*1.7))*0.5*s,
        y: (Math.sin(shakeT*2.4))*0.35*s,
        z: (Math.sin(shakeT*2.0))*0.40*s
      };
    }

    // ===== input (Îã®Ïùº Î¶¨Ïä§ÎÑàÎ°úÎßå Ï≤òÎ¶¨: Ï§ëÎ≥µ Î∞©ÏßÄ) =====
    addEventListener('keydown', (e)=>{
      keys.add(e.code);

      if(e.code==="KeyF" && !e.repeat){ fogOn = !fogOn; applyEnv(); toast(`FOG ${fogOn?"ON":"OFF"}`); }
      if(e.code==="KeyT" && !e.repeat){ isNight = !isNight; applyEnv(); toast(isNight?"NIGHT MODE":"DAY MODE"); }
      if(e.code==="KeyR" && !e.repeat){ resetAll(); toast("RESET"); }

      if(e.code.startsWith("Digit") && !e.repeat){
        const n = parseInt(e.code.slice(5), 10);
        if(n>=1 && n<=5){
          sel.value = CAR_PROFILES[n-1].id;
          sel.dispatchEvent(new Event('change'));
        }
      }
    });
    addEventListener('keyup', (e)=> keys.delete(e.code));

    function resetAll(){
      state.speed=0; state.dist=0; state.laneX=0; state.laneV=0;
      initRoad();
      consume=0;
      for(const d of deco){
        d.u=Math.random();
        d.side=Math.random()<0.5?-1:1;
        if(d.kind==="tree") d.xOff=(ROAD_WIDTH*0.9 + 6 + Math.random()*26);
        else { d.xOff=(ROAD_WIDTH*0.9 + 28 + Math.random()*70); d.y=4*(0.9+Math.random()*1.8); }
      }
    }

    // ===== start camera =====
    camera.position.set(0, 6.0, 16.0);

    // ===== loop =====
    let last = performance.now();
    toast("WÎ°ú Ï∂úÎ∞ú! 1~5Î°ú Ï∞® Î∞îÍæ∏Í∏∞ üöó");

    function tick(){
      const now = performance.now();
      const dt = Math.min(0.033, (now-last)/1000);
      last = now;

      const throttle = keys.has("KeyW") ? 1 : 0;
      const brakeIn  = keys.has("KeyS") ? 1 : 0;
      const steerIn  = (keys.has("KeyD")?1:0) - (keys.has("KeyA")?1:0);
      const boost    = keys.has("ShiftLeft") || keys.has("ShiftRight");

      const maxV = (currentCar.topSpeed/3.6) * (boost ? 1.08 : 1.0);
      const r = state.speed / Math.max(0.1, maxV);
      const engine = powerCurve(currentCar.accelTier, r);
      const accelBase = 14.0 * currentCar.accelMul * (boost ? 1.20 : 1.0) * engine;

      const brake = 18.0;
      const aeroDrag = (0.20 + state.speed*0.018) * currentCar.aero;

      if(throttle) state.speed += accelBase*dt;
      else         state.speed -= aeroDrag*dt;
      if(brakeIn)  state.speed -= brake*dt;

      state.speed = clamp(state.speed, 0, maxV);

      // steering + curve push
      const laneMax = ROAD_WIDTH/2 - 1.05;
      const steerPower = (7.2 + state.speed*0.22) / currentCar.grip;
      state.laneV += steerIn * steerPower * dt;
      state.laneV *= Math.pow(0.10, dt);
      state.laneX += state.laneV * dt;

      // curve push
      const curvePush = curv * state.speed * state.speed * 0.55 * (1.0/currentCar.grip);
      state.laneX += curvePush * dt;

      const over = Math.max(0, Math.abs(state.laneX) - laneMax);
      if(over>0){
        state.laneX -= Math.sign(state.laneX) * over * 2.7 * dt;
        state.laneV *= 0.6;
      }
      state.laneX = clamp(state.laneX, -laneMax-0.6, laneMax+0.6);

      // distance + road
      const dz = state.speed * dt;
      state.dist += dz;

      const {offX, offZ} = advanceRoad(dz);

      // update ribbon every frame (N=240, typed arrayÎùº Ï∂©Î∂ÑÌûà ÏïàÏ†ï/Îπ†Î¶Ñ)
      writeRibbon(geoShoulder, 0, offX, offZ);
      writeRibbon(geoRoad,     0, offX, offZ);
      writeRibbon(geoLineC,    0, offX, offZ);
      writeRibbon(geoLineL, -ROAD_WIDTH/2 + 0.35, offX, offZ);
      writeRibbon(geoLineR,  ROAD_WIDTH/2 - 0.35, offX, offZ);
      placeDeco(offX, offZ);

      // dashed scroll ÎäêÎÇå: v repeat ÏõÄÏßÅÏù¥Í∏∞
      dashTex.offset.y += dt * (0.35 + state.speed*0.006);

      // car placement near sample index
      const carIdx = 6;
      const y = yawArr[carIdx];
      const rx = Math.cos(y), rz = Math.sin(y);
      const fx = Math.sin(y), fz = -Math.cos(y);

      const baseX = cx[carIdx]-offX;
      const baseZ = cz[carIdx]-offZ;

      const carX = baseX + rx*state.laneX + fx*10.0;
      const carZ = baseZ + rz*state.laneX + fz*10.0;

      car.position.set(carX, 0, carZ);
      car.rotation.y = y + (-steerIn*0.10);

      // wheels spin
      const spin = state.speed * dt * 2.6;
      for(const w of car.userData.wheels) w.rotation.x -= spin;

      // lights
      const headI = isNight ? 2.2 : 0.0;
      car.userData.headL.intensity = headI;
      car.userData.headR.intensity = headI;
      car.userData.under.intensity = isNight ? 0.65 : 0.0;

      // camera
      const kmh = state.speed*3.6;
      const speed01 = clamp((kmh-30)/260, 0, 1);
      const camLow = lerp(6.0, 4.6, speed01);
      const camBack= lerp(16.0, 13.2, speed01);
      const camLook= lerp(30.0, 40.0, speed01);

      const sh = getShake(state.speed, dt);
      const camTarget = new THREE.Vector3(carX + sh.x, camLow + sh.y, carZ + camBack + sh.z);
      camera.position.lerp(camTarget, 1 - Math.pow(0.001, dt));
      camera.lookAt(carX*0.65, 1.25, carZ - camLook);

      // HUD
      document.getElementById('spd').textContent = `${Math.round(kmh)} km/h`;
      document.getElementById('dst').textContent = `${(state.dist/1000).toFixed(1)} km`;

      renderer.render(scene, camera);
      requestAnimationFrame(tick);
    }
    tick();

    // ===== resize =====
    addEventListener('resize', ()=>{
      renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
      renderer.setSize(innerWidth, innerHeight, false);
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
    });
  </script>
</body>
</html>
