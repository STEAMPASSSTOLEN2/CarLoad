<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Endless Road Drive — Physics First</title>
  <style>
    :root{
      --bg1:#0b1026;
      --bg2:#1a2a4d;
      --panel: rgba(0,0,0,.55);
      --text: #eaf0ff;
      --muted: rgba(234,240,255,.75);
      --accent: #7dd3fc;
      --danger: #ff6b6b;
      --ok: #34d399;
    }
    html,body{height:100%;margin:0;overflow:hidden;font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Apple SD Gothic Neo, Noto Sans KR, sans-serif;}
    body{
      background: radial-gradient(1200px 900px at 50% 20%, var(--bg2), var(--bg1));
      color:var(--text);
    }
    #hud{
      position:fixed;left:14px;top:14px;z-index:10;
      background:var(--panel);
      border:1px solid rgba(255,255,255,.12);
      backdrop-filter: blur(10px);
      border-radius:14px;
      padding:12px 12px 10px;
      width:min(390px, calc(100vw - 28px));
      box-shadow: 0 12px 40px rgba(0,0,0,.35);
    }
    #hud h1{margin:0 0 8px;font-size:14px;font-weight:700;letter-spacing:.2px;}
    #grid{display:grid;grid-template-columns:1fr 1fr;gap:10px;}
    .row{display:flex;gap:8px;align-items:center;}
    label{font-size:12px;color:var(--muted);}
    select,input[type="range"],button{
      width:100%;
      background: rgba(255,255,255,.06);
      color: var(--text);
      border: 1px solid rgba(255,255,255,.14);
      border-radius: 10px;
      padding: 8px 10px;
      outline:none;
    }
    input[type="range"]{padding:8px 6px;}
    button{cursor:pointer;transition:.15s transform,.15s background,.15s border-color;}
    button:hover{transform: translateY(-1px); background: rgba(255,255,255,.09); border-color: rgba(255,255,255,.2);}    
    .pill{display:inline-flex;gap:6px;align-items:center;font-size:12px;color:var(--muted);}
    .dot{width:8px;height:8px;border-radius:999px;background:rgba(255,255,255,.25);}
    .dot.ok{background:var(--ok);} .dot.bad{background:var(--danger);} .dot.on{background:var(--accent);}    
    #stats{margin-top:10px;display:grid;grid-template-columns:1fr 1fr 1fr;gap:8px;}
    .stat{
      background: rgba(255,255,255,.05);
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 12px;
      padding: 8px 10px;
    }
    .stat .k{font-size:11px;color:var(--muted);} 
    .stat .v{font-size:14px;font-weight:700;margin-top:2px;}
    #help{margin-top:10px;font-size:11px;color:var(--muted);line-height:1.35;}
    #toast{
      position:fixed;left:50%;bottom:18px;transform:translateX(-50%);
      background: rgba(0,0,0,.55);
      border: 1px solid rgba(255,255,255,.14);
      padding: 10px 12px;
      border-radius: 999px;
      font-size: 12px;
      color: var(--text);
      z-index: 20;
      opacity: 0;
      transition: opacity .2s;
      pointer-events:none;
      backdrop-filter: blur(10px);
    }
    #toast.show{opacity:1;}
    canvas{display:block;}
  </style>
</head>
<body>
  <div id="hud">
    <h1>Endless Road Drive — 물리부터 제대로</h1>
    <div id="grid">
      <div>
        <label>차량 선택</label>
        <div class="row">
          <select id="carSelect"></select>
        </div>
      </div>
      <div>
        <label>도로 폭</label>
        <div class="row">
          <input id="roadWidth" type="range" min="10" max="40" step="1" value="22" />
        </div>
      </div>
      <div>
        <label>주행 보정 (드리프트 억제)</label>
        <div class="row">
          <input id="grip" type="range" min="0.6" max="0.98" step="0.01" value="0.88" />
        </div>
      </div>
      <div>
        <label>조향 민감도</label>
        <div class="row">
          <input id="steerSens" type="range" min="0.6" max="2.0" step="0.05" value="1.15" />
        </div>
      </div>
      <div style="grid-column: 1 / -1; display:flex; gap:8px;">
        <button id="resetBtn">리셋</button>
        <button id="pauseBtn">일시정지</button>
      </div>
      <div style="grid-column: 1 / -1; display:flex; justify-content:space-between; gap:10px; flex-wrap:wrap;">
        <span class="pill"><span id="pillHead" class="dot"></span>헤드라이트(L)</span>
        <span class="pill"><span id="pillDay" class="dot on"></span>낮/밤(P)</span>
        <span class="pill"><span id="pillFog" class="dot"></span>안개(M)</span>
      </div>
    </div>
    <div id="stats">
      <div class="stat"><div class="k">속도</div><div id="spd" class="v">0 km/h</div></div>
      <div class="stat"><div class="k">조향각</div><div id="yaw" class="v">0°</div></div>
      <div class="stat"><div class="k">상태</div><div id="state" class="v">RUN</div></div>
    </div>
    <div id="help">
      <b>조작</b>: W 가속 / S 브레이크·후진 / A·D 조향 / Space 핸드브레이크 / R 리셋<br>
      <b>토글</b>: L 헤드라이트 / P 낮·밤 / M 안개 / Esc 일시정지<br>
      <span style="opacity:.9">(핵심: 이동 방향이 차 각도를 따라가도록 속도 벡터를 계속 회전시키는 방식)</span>
    </div>
  </div>
  <div id="toast"></div>

  <!-- Three.js (module) -->
  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

    // ---------- UI ----------
    const $ = (id)=>document.getElementById(id);
    const carSelect = $('carSelect');
    const roadWidthEl = $('roadWidth');
    const gripEl = $('grip');
    const steerSensEl = $('steerSens');
    const resetBtn = $('resetBtn');
    const pauseBtn = $('pauseBtn');
    const spdEl = $('spd');
    const yawEl = $('yaw');
    const stateEl = $('state');
    const pillHead = $('pillHead');
    const pillDay  = $('pillDay');
    const pillFog  = $('pillFog');
    const toast = $('toast');

    const showToast = (msg)=>{
      toast.textContent = msg;
      toast.classList.add('show');
      clearTimeout(showToast._t);
      showToast._t = setTimeout(()=>toast.classList.remove('show'), 1100);
    };

    // ---------- Presets ----------
    // topSpeed in km/h target, accel in m/s^2-ish scale, mass affects inertia (turn response), brake strength
    const CAR_PRESETS = [
      { name:'Hyundai IONIQ 5 N', topSpeed:150, accel:7.0, brake:10.0, mass:1450, steerLimitDeg:32 },
      { name:'Mazda Furai',       topSpeed:250, accel:8.2, brake:11.0, mass:1200, steerLimitDeg:30 },
      { name:'Huracán EVO Spyder',topSpeed:330, accel:9.0, brake:12.0, mass:1350, steerLimitDeg:28 },
      { name:'Agera RS',         topSpeed:400, accel:10.5, brake:13.0, mass:1400, steerLimitDeg:26 },
      { name:'Devel Sixteen',    topSpeed:552, accel:13.0, brake:15.0, mass:1650, steerLimitDeg:24 },
    ];

    CAR_PRESETS.forEach((c,i)=>{
      const opt = document.createElement('option');
      opt.value = String(i);
      opt.textContent = c.name;
      carSelect.appendChild(opt);
    });

    // ---------- Three Scene ----------
    const renderer = new THREE.WebGLRenderer({ antialias:true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.body.appendChild(renderer.domElement);

    const scene = new THREE.Scene();

    const camera = new THREE.PerspectiveCamera(65, window.innerWidth/window.innerHeight, 0.1, 1200);
    camera.position.set(0, 6.5, 12);

    // Lights (day/night toggle)
    const hemi = new THREE.HemisphereLight(0xbfd7ff, 0x0b0f16, 0.9);
    scene.add(hemi);

    const sun = new THREE.DirectionalLight(0xffffff, 1.1);
    sun.position.set(40, 60, -10);
    sun.castShadow = true;
    sun.shadow.mapSize.set(2048,2048);
    sun.shadow.camera.near = 1;
    sun.shadow.camera.far = 220;
    sun.shadow.camera.left = -80;
    sun.shadow.camera.right = 80;
    sun.shadow.camera.top = 80;
    sun.shadow.camera.bottom = -80;
    scene.add(sun);

    // Fog (toggle)
    let fogOn = false;
    const fog = new THREE.Fog(0x0c1220, 35, 170);

    // Ground
    const ground = new THREE.Mesh(
      new THREE.PlaneGeometry(900, 900, 1, 1),
      new THREE.MeshStandardMaterial({ color: 0x16202c, roughness: 1.0, metalness: 0.0 })
    );
    ground.rotation.x = -Math.PI/2;
    ground.receiveShadow = true;
    scene.add(ground);

    // Road (endless tiles)
    const roadGroup = new THREE.Group();
    scene.add(roadGroup);

    const roadMat = new THREE.MeshStandardMaterial({ color: 0x252a31, roughness: 0.9, metalness: 0.0 });
    const laneMat = new THREE.MeshStandardMaterial({ color: 0xe9f0ff, roughness: 0.4, metalness: 0.0, emissive:0x0, emissiveIntensity:0.0 });

    let ROAD_WIDTH = Number(roadWidthEl.value);
    const ROAD_LEN = 70;
    const TILE_COUNT = 10;

    const tiles = [];

    function makeTile(z){
      const g = new THREE.Group();

      const road = new THREE.Mesh(new THREE.BoxGeometry(ROAD_WIDTH, 0.35, ROAD_LEN), roadMat);
      road.position.y = 0.175;
      road.castShadow = false;
      road.receiveShadow = true;
      g.add(road);

      // Lane dashed lines
      const dashCount = 10;
      for(let i=0;i<dashCount;i++){
        const dash = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.02, ROAD_LEN/(dashCount*1.7)), laneMat);
        dash.position.set(0, 0.38, -ROAD_LEN/2 + (i+0.5)*(ROAD_LEN/dashCount));
        dash.receiveShadow = false;
        g.add(dash);
      }

      // Guardrails (physics is handled via clamp & bounce + visuals)
      const railH = 0.8;
      const railT = 0.25;
      const railOffset = ROAD_WIDTH/2 + 0.65;
      const railMat = new THREE.MeshStandardMaterial({ color: 0x3a4049, roughness: 0.6, metalness: 0.25 });

      const leftRail = new THREE.Mesh(new THREE.BoxGeometry(railT, railH, ROAD_LEN), railMat);
      leftRail.position.set(-railOffset, railH/2, 0);
      leftRail.castShadow = true;
      leftRail.receiveShadow = true;
      g.add(leftRail);

      const rightRail = new THREE.Mesh(new THREE.BoxGeometry(railT, railH, ROAD_LEN), railMat);
      rightRail.position.set(railOffset, railH/2, 0);
      rightRail.castShadow = true;
      rightRail.receiveShadow = true;
      g.add(rightRail);

      g.position.z = z;
      return g;
    }

    function rebuildRoad(){
      ROAD_WIDTH = Number(roadWidthEl.value);
      // remove old tiles
      for(const t of tiles){ roadGroup.remove(t); }
      tiles.length = 0;
      // rebuild
      for(let i=0;i<TILE_COUNT;i++){
        const z = -i*ROAD_LEN;
        const tile = makeTile(z);
        tiles.push(tile);
        roadGroup.add(tile);
      }
      showToast(`도로 폭: ${ROAD_WIDTH.toFixed(0)}m`);
    }

    rebuildRoad();

    // Car model (simple)
    const car = new THREE.Group();
    scene.add(car);

    const body = new THREE.Mesh(
      new THREE.BoxGeometry(1.75, 0.6, 3.6),
      new THREE.MeshStandardMaterial({ color: 0x3b82f6, roughness: 0.45, metalness: 0.35 })
    );
    body.castShadow = true;
    body.receiveShadow = true;
    body.position.y = 0.55;
    car.add(body);

    const cabin = new THREE.Mesh(
      new THREE.BoxGeometry(1.45, 0.55, 1.6),
      new THREE.MeshStandardMaterial({ color: 0x111827, roughness: 0.15, metalness: 0.2, transparent:true, opacity:0.85 })
    );
    cabin.castShadow = true;
    cabin.position.set(0, 0.95, -0.1);
    car.add(cabin);

    const wheelMat = new THREE.MeshStandardMaterial({ color: 0x0b0f16, roughness: 0.95, metalness: 0.05 });
    const wheelGeo = new THREE.CylinderGeometry(0.32, 0.32, 0.24, 18);
    function addWheel(x,z){
      const w = new THREE.Mesh(wheelGeo, wheelMat);
      w.rotation.z = Math.PI/2;
      w.position.set(x, 0.32, z);
      w.castShadow = true;
      car.add(w);
      return w;
    }
    const wFL = addWheel(-0.85, 1.2);
    const wFR = addWheel( 0.85, 1.2);
    const wRL = addWheel(-0.85,-1.2);
    const wRR = addWheel( 0.85,-1.2);

    // Headlights (항상 차 전방을 향하도록 target을 로컬 +Z에 고정)
    const headlightL = new THREE.SpotLight(0xffffff, 0.0, 90, THREE.MathUtils.degToRad(20), 0.25, 1.4);
    headlightL.position.set(-0.45, 0.85, 1.65);
    headlightL.target.position.set(-0.45, 0.85, -6.0);
    headlightL.castShadow = false;
    car.add(headlightL);
    car.add(headlightL.target);

    const headlightR = new THREE.SpotLight(0xffffff, 0.0, 90, THREE.MathUtils.degToRad(20), 0.25, 1.4);
    headlightR.position.set(0.45, 0.85, 1.65);
    headlightR.target.position.set(0.45, 0.85, -6.0);
    headlightR.castShadow = false;
    car.add(headlightR);
    car.add(headlightR.target);

    let headlightsOn = false;

    // ---------- Physics ----------
    const state = {
      paused: false,
      // pose
      pos: new THREE.Vector3(0, 0, 0),
      yaw: 0,                 // radians
      // velocities (car local frame)
      vForward: 0,            // m/s
      vSide: 0,               // m/s (lateral slip)
      // input
      throttle: 0,
      brake: 0,
      steer: 0,
      handbrake: 0,
      // car params
      presetIndex: 2,
      params: null,
    };

    function applyPreset(i){
      state.presetIndex = i;
      const p = CAR_PRESETS[i];
      state.params = {
        topSpeed: p.topSpeed / 3.6, // m/s
        accel: p.accel,
        brake: p.brake,
        mass: p.mass,
        steerLimit: THREE.MathUtils.degToRad(p.steerLimitDeg),
      };
      // subtle car color per preset
      const colors = [0x60a5fa,0xf97316,0xef4444,0xa78bfa,0x22c55e];
      body.material.color.setHex(colors[i % colors.length]);
      showToast(`차량: ${p.name}`);
    }

    applyPreset(state.presetIndex);
    carSelect.value = String(state.presetIndex);

    function reset(){
      state.pos.set(0,0,0);
      state.yaw = 0;
      state.vForward = 0;
      state.vSide = 0;
      // keep road centered
      roadGroup.position.set(0,0,0);
      showToast('리셋 완료');
    }

    // Input
    const keys = new Set();
    window.addEventListener('keydown', (e)=>{
      if(e.repeat) return;
      keys.add(e.code);

      if(e.code === 'KeyL'){
        headlightsOn = !headlightsOn;
        headlightL.intensity = headlightsOn ? 2.2 : 0.0;
        headlightR.intensity = headlightsOn ? 2.2 : 0.0;
        pillHead.className = 'dot ' + (headlightsOn ? 'on' : '');
        showToast(`헤드라이트: ${headlightsOn ? 'ON' : 'OFF'}`);
      }
      if(e.code === 'KeyP'){
        // day/night
        const isNight = sun.intensity > 0.2;
        if(isNight){
          sun.intensity = 0.18;
          hemi.intensity = 0.35;
          scene.background = new THREE.Color(0x060814);
          laneMat.emissive = new THREE.Color(0xe9f0ff);
          laneMat.emissiveIntensity = 0.25;
          pillDay.className = 'dot';
          showToast('밤 모드');
        }else{
          sun.intensity = 1.1;
          hemi.intensity = 0.9;
          scene.background = null;
          laneMat.emissiveIntensity = 0.0;
          pillDay.className = 'dot on';
          showToast('낮 모드');
        }
      }
      if(e.code === 'KeyM'){
        fogOn = !fogOn;
        scene.fog = fogOn ? fog : null;
        pillFog.className = 'dot ' + (fogOn ? 'on' : '');
        showToast(`안개: ${fogOn ? 'ON' : 'OFF'}`);
      }

      if(e.code === 'KeyR') reset();
      if(e.code === 'Escape') togglePause();
    });

    window.addEventListener('keyup', (e)=>{
      keys.delete(e.code);
    });

    function togglePause(){
      state.paused = !state.paused;
      stateEl.textContent = state.paused ? 'PAUSE' : 'RUN';
      pauseBtn.textContent = state.paused ? '재개' : '일시정지';
      showToast(state.paused ? '일시정지' : '재개');
    }

    resetBtn.addEventListener('click', reset);
    pauseBtn.addEventListener('click', togglePause);

    carSelect.addEventListener('change', ()=>{
      applyPreset(Number(carSelect.value));
      reset();
    });

    roadWidthEl.addEventListener('input', ()=>{
      rebuildRoad();
    });

    // ---------- Camera follow ----------
    const camOffset = new THREE.Vector3(0, 6.2, 12.5);

    // ---------- Simulation loop ----------
    const clock = new THREE.Clock();

    function clamp(v,a,b){ return Math.max(a, Math.min(b,v)); }

    function updateInput(){
      // 포커스가 게임 캔버스/문서에 있을 때만 입력 허용 (UI 클릭 시 오작동 방지)
      if(document.activeElement && ['INPUT','SELECT','BUTTON','TEXTAREA'].includes(document.activeElement.tagName)){
        state.throttle = 0; state.brake = 0; state.steer = 0; state.handbrake = 0; return;
      }
      const w = keys.has('KeyW') || keys.has('ArrowUp');
      const s = keys.has('KeyS') || keys.has('ArrowDown');
      const a = keys.has('KeyA') || keys.has('ArrowLeft');
      const d = keys.has('KeyD') || keys.has('ArrowRight');
      const space = keys.has('Space');

      state.throttle = w ? 1 : 0;
      state.brake = s ? 1 : 0;
      state.steer = (a ? 1 : 0) + (d ? -1 : 0);
      state.handbrake = space ? 1 : 0;
    }

    function step(dt){
      updateInput();

      const p = state.params;
      const grip = Number(gripEl.value);               // 0.6~0.98 (higher = less drift)
      const steerSens = Number(steerSensEl.value);     // UI scalar

      // --- Longitudinal forces ---
      // Engine: reduces as you approach top speed
      const speedAbs = Math.abs(state.vForward);
      const speedRatio = clamp(speedAbs / p.topSpeed, 0, 1);
      const engine = state.throttle * p.accel * (1.0 - 0.55*speedRatio);

      // Brake: strong opposing force
      const braking = state.brake * p.brake;

      // Integrate forward speed
      // If braking and moving forward -> decel; if braking and near 0 -> reverse allowed
      let aForward = engine;
      if(state.brake > 0){
        aForward -= Math.sign(state.vForward || 1) * braking;
      }

      state.vForward += aForward * dt;

      // Limit top speed (forward & reverse)
      const maxF = p.topSpeed;
      const maxR = maxF * 0.28;
      state.vForward = clamp(state.vForward, -maxR, maxF);

      // Rolling resistance / air drag
      const drag = 0.55 + 1.35*speedRatio; // increases with speed
      state.vForward *= Math.exp(-drag * dt * 0.12);

      // --- Steering ---
      // Speed-based steering: low speed -> less effect, high speed -> stronger but limited
      const steerLimit = p.steerLimit;
      const steerInput = clamp(state.steer, -1, 1);

      const steerGain = (0.25 + 0.75*clamp(speedAbs / 14.0, 0, 1));
      const steerAngle = steerInput * steerLimit * steerGain * steerSens;

      // Yaw rate roughly proportional to forward speed and steer angle
      // Longer "wheelbase" reduces yaw rate (simulate heavier cars)
      const wheelbase = 2.7;
      const inertia = clamp(p.mass / 1400, 0.85, 1.35);
      const yawRate = (state.vForward / wheelbase) * Math.tan(steerAngle) / inertia;
      state.yaw += yawRate * dt;

      // --- Lateral dynamics (simple slip model) ---
      // Convert forward movement into lateral slip when turning. Handbrake increases slip.
      const slipAdd = Math.abs(yawRate) * (2.2 + 4.0*state.handbrake) * dt;
      state.vSide += Math.sign(steerInput) * slipAdd * Math.sign(state.vForward || 1);

      // Apply grip to kill lateral velocity (this fixes "angle changes but direction stays" feel)
      // Higher grip -> faster lateral damping
      const sideDamp = 1.0 - grip;
      state.vSide *= Math.exp(- (3.0 + 10.0*sideDamp) * dt);

      // Handbrake also reduces forward speed a bit
      if(state.handbrake){
        state.vForward *= Math.exp(-2.2 * dt);
      }

      // --- Move in world space ---
      // 좌표계 기준: 카메라가 +Z 쪽에 있으므로, 차의 "전방"을 -Z로 정의 (W 누르면 화면 안쪽으로 달림)
      const sin = Math.sin(state.yaw);
      const cos = Math.cos(state.yaw);

      // local(car) -> world
      // forward(-Z) = (sin, 0, -cos)
      // right(+X)   = (cos, 0,  sin)
      const vx = sin * state.vForward + cos * state.vSide;
      const vz = -cos * state.vForward + sin * state.vSide;

      state.pos.x += vx * dt;
      state.pos.z += vz * dt;

      // --- Road boundaries & "guardrail collision" ---
      const half = ROAD_WIDTH / 2;
      const margin = 1.25; // car half width + cushion
      const limit = half - margin;

      if(state.pos.x > limit){
        state.pos.x = limit;
        // bounce: reflect lateral speed + lose forward speed
        state.vSide *= -0.35;
        state.vForward *= 0.78;
      }
      if(state.pos.x < -limit){
        state.pos.x = -limit;
        state.vSide *= -0.35;
        state.vForward *= 0.78;
      }

      // --- Endless road tile recycling ---
      // Keep tiles around the car along Z.
      // Find the farthest tile behind and move it ahead when needed.
      const carZ = state.pos.z;
      for(const t of tiles){
        const worldZ = t.position.z;
        // if tile is too far behind the car, move it ahead
        if(worldZ > carZ + ROAD_LEN){
          // Note: tiles are laid negative initially, but carZ may go negative too depending on direction.
          // We'll reposition based on the smallest z among tiles.
          let minZ = Infinity;
          for(const u of tiles) minZ = Math.min(minZ, u.position.z);
          t.position.z = minZ - ROAD_LEN;
        }
        if(worldZ < carZ - ROAD_LEN*(TILE_COUNT-2)){
          let maxZ = -Infinity;
          for(const u of tiles) maxZ = Math.max(maxZ, u.position.z);
          t.position.z = maxZ + ROAD_LEN;
        }
      }

      // --- Update visuals ---
      car.position.set(state.pos.x, 0, state.pos.z);
      car.rotation.y = state.yaw;

      // wheel spin
      const wheelSpin = state.vForward * dt * 2.4;
      wFL.rotation.x += wheelSpin;
      wFR.rotation.x += wheelSpin;
      wRL.rotation.x += wheelSpin;
      wRR.rotation.x += wheelSpin;

      // camera follow (smooth)
      const desired = new THREE.Vector3().copy(camOffset)
        .applyAxisAngle(new THREE.Vector3(0,1,0), state.yaw)
        .add(car.position);
      camera.position.lerp(desired, 1 - Math.exp(-6.5*dt));
      const lookAt = new THREE.Vector3().copy(car.position)
        .add(new THREE.Vector3(0, 1.2, -2).applyAxisAngle(new THREE.Vector3(0,1,0), state.yaw));
      camera.lookAt(lookAt);

      // HUD
      const kmh = Math.abs(state.vForward) * 3.6;
      spdEl.textContent = `${kmh.toFixed(0)} km/h`;
      yawEl.textContent = `${(THREE.MathUtils.radToDeg(state.yaw)%360+360)%360|0}°`;
    }

    function animate(){
      const dt = Math.min(clock.getDelta(), 0.033);
      if(!state.paused){
        step(dt);
      }
      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }

    // Resize
    window.addEventListener('resize', ()=>{
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    });

    // Init pills
    pillHead.className = 'dot';
    pillFog.className = 'dot';

    // Start
    showToast('준비 완료 — W로 가속!');
    animate();
  </script>
</body>
</html>
