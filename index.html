<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Slow Roads 3D - Mini</title>
  <style>
    html,body{height:100%;margin:0;overflow:hidden;background:#060812;font-family:system-ui,-apple-system,"Apple SD Gothic Neo","Noto Sans KR",sans-serif}
    #ui{
      position:fixed;left:14px;top:14px;z-index:10;
      color:#eaf0ff;background:rgba(10,14,26,.55);
      border:1px solid rgba(255,255,255,.10);
      padding:10px 12px;border-radius:14px;backdrop-filter: blur(10px);
      box-shadow:0 12px 32px rgba(0,0,0,.35); user-select:none;
      max-width:min(520px, calc(100vw - 28px));
    }
    .t{font-weight:900;letter-spacing:-.2px}
    .s{color:rgba(234,240,255,.78);font-size:13px;margin-top:4px;line-height:1.35}
    .kbd{font-family:ui-monospace,SFMono-Regular,Menlo,monospace;padding:2px 6px;border-radius:8px;border:1px solid rgba(255,255,255,.12);background:rgba(255,255,255,.06)}
    #hud{
      position:fixed;right:14px;top:14px;z-index:10;
      color:#eaf0ff;background:rgba(10,14,26,.55);
      border:1px solid rgba(255,255,255,.10);
      padding:10px 12px;border-radius:14px;backdrop-filter: blur(10px);
      box-shadow:0 12px 32px rgba(0,0,0,.35); user-select:none;
      text-align:right; min-width:170px;
    }
    #hud .big{font-weight:950;font-size:18px}
    #hud .small{color:rgba(234,240,255,.72);font-size:12px;margin-top:2px}
    #hint{
      position:fixed;left:50%;bottom:18px;transform:translateX(-50%);
      color:#eaf0ff;background:rgba(10,14,26,.62);
      border:1px solid rgba(255,255,255,.10);
      padding:10px 14px;border-radius:999px;backdrop-filter: blur(10px);
      box-shadow:0 12px 32px rgba(0,0,0,.35);
      font-size:13px; user-select:none; pointer-events:none;
      opacity:0; transition:opacity .25s ease, transform .25s ease;
      max-width:min(620px, calc(100vw - 28px));
      text-align:center; line-height:1.35;
    }
    #hint.on{opacity:1; transform:translateX(-50%) translateY(-4px);}
    canvas{display:block}
  </style>
</head>
<body>
  <div id="ui">
    <div class="t">Slow Roads 3D - Mini</div>
    <div class="s">
      <span class="kbd">W</span>/<span class="kbd">S</span> ê°€ì†/ê°ì† Â·
      <span class="kbd">A</span>/<span class="kbd">D</span> ì¡°í–¥ Â·
      <span class="kbd">Shift</span> ë¶€ìŠ¤íŠ¸ Â·
      <span class="kbd">F</span> ì•ˆê°œ Â·
      <span class="kbd">T</span> ë‚®/ë°¤ Â·
      <span class="kbd">R</span> ë¦¬ì…‹
    </div>
    <div class="s">íŒ: ì»¤ë¸ŒëŠ” ìë™ìœ¼ë¡œ ìƒì„±ë¼. ë„ˆë¬´ ë°”ê¹¥ìœ¼ë¡œ ë‚˜ê°€ë©´ ì‚´ì§ ë¯¸ë„ëŸ¬ì ¸ì„œ ë³µê·€í•´.</div>
  </div>

  <div id="hud">
    <div class="big" id="spd">0 km/h</div>
    <div class="small" id="dst">0.0 km</div>
    <div class="small" id="mode">DAY Â· FOG: OFF</div>
  </div>

  <div id="hint"></div>

  <!-- Three.js (CDN) -->
  <script type="module">
    import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";

    // ===== Utils =====
    const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
    const lerp  = (a,b,t)=>a+(b-a)*t;

    function toast(msg){
      const el = document.getElementById('hint');
      el.textContent = msg;
      el.classList.add('on');
      clearTimeout(toast._t);
      toast._t = setTimeout(()=>el.classList.remove('on'), 900);
    }

    // ===== Renderer / Scene / Camera =====
    const renderer = new THREE.WebGLRenderer({ antialias:true });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.setSize(innerWidth, innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    document.body.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(65, innerWidth/innerHeight, 0.1, 1500);

    // ===== Lighting & Atmosphere (Day/Night) =====
    let isNight = false;
    let fogOn = false;

    const hemi = new THREE.HemisphereLight(0xbcd7ff, 0x101018, 0.9);
    scene.add(hemi);

    const sun = new THREE.DirectionalLight(0xffffff, 1.2);
    sun.position.set(50, 120, 40);
    sun.castShadow = false;
    scene.add(sun);

    // Stars (night)
    const starGeo = new THREE.BufferGeometry();
    const starCount = 1200;
    const starPos = new Float32Array(starCount * 3);
    for(let i=0;i<starCount;i++){
      const r = 600 + Math.random()*600;
      const th = Math.random()*Math.PI*2;
      const ph = Math.random()*Math.PI*0.45; // upper-ish
      starPos[i*3+0] = Math.cos(th)*Math.sin(ph)*r;
      starPos[i*3+1] = 200 + Math.cos(ph)*r*0.15;
      starPos[i*3+2] = Math.sin(th)*Math.sin(ph)*r;
    }
    starGeo.setAttribute('position', new THREE.BufferAttribute(starPos, 3));
    const stars = new THREE.Points(starGeo, new THREE.PointsMaterial({ color:0xffffff, size:1.2, sizeAttenuation:true, transparent:true, opacity:0.0 }));
    scene.add(stars);

    function applyEnv(){
      if(!isNight){
        scene.background = new THREE.Color(0x9fc7ff);
        hemi.intensity = 0.95;
        sun.intensity = 1.15;
        sun.color.setHex(0xffffff);
        stars.material.opacity = 0.0;
      }else{
        scene.background = new THREE.Color(0x050611);
        hemi.intensity = 0.25;
        sun.intensity = 0.35;
        sun.color.setHex(0xaac6ff);
        stars.material.opacity = 0.9;
      }
      if(fogOn){
        scene.fog = new THREE.Fog(isNight ? 0x050611 : 0x9fc7ff, 40, 260);
      }else{
        scene.fog = null;
      }
      document.getElementById('mode').textContent = `${isNight ? "NIGHT" : "DAY"} Â· FOG: ${fogOn ? "ON" : "OFF"}`;
    }
    applyEnv();

    // ===== Road settings =====
    const ROAD_WIDTH = 10;
    const ROAD_LEN = 60;          // per segment length (z)
    const SEG_COUNT = 26;         // number of visible segments
    const RECYCLE_Z = ROAD_LEN * SEG_COUNT;

    // The road is made of repeating segments. Each segment has an x-offset and yaw to make curves.
    const segments = [];

    // Materials
    const matRoad = new THREE.MeshStandardMaterial({ color:0x2b2f3a, roughness:0.95, metalness:0.0 });
    const matShoulder = new THREE.MeshStandardMaterial({ color:0x1b1e26, roughness:1.0, metalness:0.0 });
    const matLine = new THREE.MeshStandardMaterial({ color:0xe7ecff, roughness:0.35, metalness:0.0, emissive:0x0, emissiveIntensity:0.0 });

    // Geometry
    const geoRoad = new THREE.PlaneGeometry(ROAD_WIDTH, ROAD_LEN, 1, 1);
    geoRoad.rotateX(-Math.PI/2);

    const geoShoulder = new THREE.PlaneGeometry(ROAD_WIDTH*2.2, ROAD_LEN, 1, 1);
    geoShoulder.rotateX(-Math.PI/2);

    const geoLine = new THREE.PlaneGeometry(0.18, ROAD_LEN*0.7, 1, 1);
    geoLine.rotateX(-Math.PI/2);

    // Procedural curve generator (smoothly varying)
    let curvePhase = 0;
    let curveTarget = 0;
    let curveCurrent = 0;

    function nextCurveTarget(){
      // Small random curve with occasional stronger bends
      const base = (Math.random()*2-1) * 0.055;
      const spice = (Math.random()<0.18) ? (Math.random()*2-1) * 0.10 : 0;
      curveTarget = clamp(base + spice, -0.12, 0.12);
    }
    nextCurveTarget();

    function buildSegment(zIndex){
      const g = new THREE.Group();

      const shoulder = new THREE.Mesh(geoShoulder, matShoulder);
      shoulder.position.y = 0;
      g.add(shoulder);

      const road = new THREE.Mesh(geoRoad, matRoad);
      road.position.y = 0.01;
      g.add(road);

      // Center dashed line
      const dash = new THREE.Mesh(geoLine, matLine);
      dash.position.y = 0.02;
      dash.position.x = 0;
      g.add(dash);

      // Side lines
      const sideL = new THREE.Mesh(geoLine, matLine);
      sideL.scale.x = 0.9;
      sideL.position.y = 0.02;
      sideL.position.x = -ROAD_WIDTH/2 + 0.35;
      g.add(sideL);

      const sideR = sideL.clone();
      sideR.position.x = ROAD_WIDTH/2 - 0.35;
      g.add(sideR);

      // Place initial z
      g.position.z = -zIndex * ROAD_LEN;
      scene.add(g);

      return { group:g, zIndex, xOff:0, yaw:0 };
    }

    for(let i=0;i<SEG_COUNT;i++){
      segments.push(buildSegment(i));
    }

    // ===== Simple scenery (trees + mountains) =====
    const scenery = new THREE.Group();
    scene.add(scenery);

    const treeMatTop = new THREE.MeshStandardMaterial({ color:0x2dd4bf, roughness:0.9 });
    const treeMatTrk = new THREE.MeshStandardMaterial({ color:0x5b3a22, roughness:1.0 });
    const hillMat = new THREE.MeshStandardMaterial({ color:0x2a3252, roughness:1.0 });

    const treeGeoTop = new THREE.ConeGeometry(1.2, 3.5, 7);
    const treeGeoTrk = new THREE.CylinderGeometry(0.25, 0.35, 1.6, 6);

    const hillGeo = new THREE.SphereGeometry(10, 10, 8);

    const deco = []; // objects with baseZ for recycling

    function addTree(x, z, s=1){
      const t = new THREE.Group();
      const trunk = new THREE.Mesh(treeGeoTrk, treeMatTrk);
      trunk.position.y = 0.8*s;
      trunk.scale.setScalar(s);
      t.add(trunk);
      const top = new THREE.Mesh(treeGeoTop, treeMatTop);
      top.position.y = 3.1*s;
      top.scale.setScalar(s);
      t.add(top);
      t.position.set(x, 0, z);
      scenery.add(t);
      deco.push({ obj:t, kind:"tree" });
    }

    function addHill(x, z, s=1){
      const h = new THREE.Mesh(hillGeo, hillMat);
      h.scale.set(1.7*s, 0.7*s, 1.2*s);
      h.position.set(x, 4*s, z);
      scenery.add(h);
      deco.push({ obj:h, kind:"hill" });
    }

    function seedScenery(){
      for(let i=0;i<140;i++){
        const z = -Math.random()*RECYCLE_Z;
        const side = Math.random()<0.5 ? -1 : 1;
        const x = side*(ROAD_WIDTH*0.9 + 6 + Math.random()*26);
        addTree(x, z, 0.7 + Math.random()*0.9);
      }
      for(let i=0;i<36;i++){
        const z = -Math.random()*RECYCLE_Z;
        const side = Math.random()<0.5 ? -1 : 1;
        const x = side*(ROAD_WIDTH*0.9 + 28 + Math.random()*70);
        addHill(x, z, 0.9 + Math.random()*1.8);
      }
    }
    seedScenery();

    // ===== Player (a simple car) =====
    const car = new THREE.Group();
    scene.add(car);

    const carBody = new THREE.Mesh(
      new THREE.BoxGeometry(1.6, 0.5, 3.2),
      new THREE.MeshStandardMaterial({ color:0x7c5cff, roughness:0.35, metalness:0.1, emissive:0x0 })
    );
    carBody.position.y = 0.55;
    car.add(carBody);

    const carCabin = new THREE.Mesh(
      new THREE.BoxGeometry(1.2, 0.5, 1.3),
      new THREE.MeshStandardMaterial({ color:0x14192b, roughness:0.25, metalness:0.0 })
    );
    carCabin.position.set(0, 0.9, -0.3);
    car.add(carCabin);

    // Headlights for night
    const headL = new THREE.SpotLight(0xdde9ff, 0.0, 60, Math.PI/8, 0.55, 1.0);
    headL.position.set(-0.55, 0.8, 1.4);
    headL.target.position.set(-0.55, 0.2, 20);
    car.add(headL);
    car.add(headL.target);

    const headR = headL.clone();
    headR.position.x = 0.55;
    headR.target.position.x = 0.55;
    car.add(headR);
    car.add(headR.target);

    // Car state
    const state = {
      speed: 0,        // m/s-ish
      dist: 0,         // meters
      x: 0,            // lateral position
      xVel: 0,
      laneMax: ROAD_WIDTH/2 - 1.0,
      zScroll: 0
    };

    // ===== Controls =====
    const keys = new Set();
    addEventListener('keydown', (e)=>{
      keys.add(e.code);

      if(e.code === "KeyF"){ fogOn = !fogOn; applyEnv(); toast(`FOG ${fogOn ? "ON" : "OFF"}`); }
      if(e.code === "KeyT"){ isNight = !isNight; applyEnv(); toast(isNight ? "NIGHT MODE" : "DAY MODE"); }
      if(e.code === "KeyR"){ reset(); toast("RESET"); }
    });
    addEventListener('keyup', (e)=> keys.delete(e.code));

    function reset(){
      state.speed = 0;
      state.dist = 0;
      state.x = 0;
      state.xVel = 0;
      state.zScroll = 0;
      curvePhase = 0;
      curveCurrent = 0;
      nextCurveTarget();
      // reset segments positions
      segments.forEach((s,i)=>{
        s.group.position.z = -i*ROAD_LEN;
        s.group.position.x = 0;
        s.group.rotation.y = 0;
        s.xOff = 0; s.yaw = 0;
      });
      // reset scenery z into range
      deco.forEach(d=>{
        d.obj.position.z = -Math.random()*RECYCLE_Z;
      });
    }

    // ===== Camera follow =====
    camera.position.set(0, 4.5, 10);
    camera.lookAt(0, 1.2, -12);

    // ===== Animation loop =====
    let last = performance.now();

    function update(dt){
      // Inputs
      const accel = (keys.has("KeyW") ? 1 : 0) - (keys.has("KeyS") ? 1 : 0);
      const steer = (keys.has("KeyD") ? 1 : 0) - (keys.has("KeyA") ? 1 : 0);
      const boost = keys.has("ShiftLeft") || keys.has("ShiftRight");

      const maxSpd = boost ? 52 : 36;       // ~km/h ëŠë‚Œìœ¼ë¡œ
      const a = boost ? 18 : 12;
      const drag = 6.5;

      state.speed += accel * a * dt;
      state.speed -= drag * dt * (state.speed / Math.max(1, maxSpd));
      state.speed = clamp(state.speed, 0, maxSpd);

      // Lateral movement with springy feel
      const steerPower = 9.5 + state.speed*0.05;
      state.xVel += steer * steerPower * dt;
      state.xVel *= Math.pow(0.12, dt);      // damping
      state.x += state.xVel * dt;

      // Soft clamp + return if outside lane
      const over = Math.max(0, Math.abs(state.x) - state.laneMax);
      if(over > 0){
        state.x -= Math.sign(state.x) * over * 2.2 * dt;
        state.xVel *= 0.6;
      }
      state.x = clamp(state.x, -state.laneMax-0.6, state.laneMax+0.6);

      // Distance / scroll
      const dz = state.speed * dt * 3.2; // scale to feel faster
      state.dist += dz;
      state.zScroll += dz;

      // Curve: smoothly drift curveCurrent toward target and occasionally pick new target
      curvePhase += dt * (0.45 + state.speed*0.012);
      if(curvePhase > 1){
        curvePhase = 0;
        nextCurveTarget();
      }
      curveCurrent = lerp(curveCurrent, curveTarget, 0.6*dt);
      // Lateral drift due to road curve (auto-centering feel)
      state.x += curveCurrent * state.speed * 0.06 * dt;

      // Move/recycle road segments forward
      // We simulate movement by moving segments towards +z (towards camera) and wrapping.
      segments.forEach((seg)=>{
        seg.group.position.z += dz;
      });

      // recycle: if segment passes camera, wrap to far back and update its curve offset/yaw
      for(const seg of segments){
        if(seg.group.position.z > ROAD_LEN){
          seg.group.position.z -= RECYCLE_Z;

          // Apply curve to next segment: accumulate x offset and yaw
          // Use curveCurrent plus some micro variation
          const micro = (Math.random()*2-1) * 0.010;
          seg.yaw = clamp(curveCurrent + micro, -0.18, 0.18);
          seg.xOff = (segments[(segments.indexOf(seg)-1+segments.length)%segments.length].xOff || 0) + seg.yaw*2.5;

          // Keep road centered within reasonable bounds
          seg.xOff = clamp(seg.xOff, -18, 18);
          seg.group.position.x = seg.xOff;
          seg.group.rotation.y = seg.yaw;
        }
      }

      // Update car position on road (use current segment center as base)
      // Find the segment nearest z=0 (camera area)
      let nearest = segments[0];
      let best = Infinity;
      for(const s of segments){
        const d = Math.abs(s.group.position.z - 0);
        if(d < best){ best = d; nearest = s; }
      }
      const baseX = nearest.group.position.x;
      car.position.set(baseX + state.x, 0, 2.5);
      car.rotation.y = -steer*0.10 + nearest.group.rotation.y*0.25;

      // Headlights intensity at night
      const headI = isNight ? 2.2 : 0.0;
      headL.intensity = headI;
      headR.intensity = headI;

      // Recycle scenery to stay ahead/behind
      deco.forEach(d=>{
        d.obj.position.z += dz;
        if(d.obj.position.z > 30){
          d.obj.position.z -= RECYCLE_Z;

          // Re-randomize x a bit on recycle
          const side = Math.random()<0.5 ? -1 : 1;
          if(d.kind === "tree"){
            d.obj.position.x = side*(ROAD_WIDTH*0.9 + 6 + Math.random()*26);
          }else{
            d.obj.position.x = side*(ROAD_WIDTH*0.9 + 28 + Math.random()*70);
          }
        }
      });

      // Camera follow (smooth)
      const camTargetPos = new THREE.Vector3(car.position.x, 4.8, 11.5);
      camera.position.lerp(camTargetPos, 1 - Math.pow(0.001, dt));
      const lookAt = new THREE.Vector3(car.position.x*0.75, 1.2, -18);
      camera.lookAt(lookAt);

      // Update HUD
      const kmh = Math.round(state.speed * 3.2); // stylized
      document.getElementById('spd').textContent = `${kmh} km/h`;
      document.getElementById('dst').textContent = `${(state.dist/1000).toFixed(1)} km`;
    }

    function animate(){
      const now = performance.now();
      const dt = Math.min(0.033, (now - last)/1000);
      last = now;

      update(dt);
      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }
    animate();

    addEventListener('resize', ()=>{
      renderer.setSize(innerWidth, innerHeight);
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
    });

    toast("Wë¡œ ì¶œë°œí•´ë´ ğŸš—");
  </script>
</body>
</html>
